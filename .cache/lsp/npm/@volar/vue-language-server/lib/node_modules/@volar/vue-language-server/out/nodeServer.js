Object.defineProperty(exports, "__esModule", { value: true });
const shared = require("@volar/shared");
const fs = require("fs");
const request_light_1 = require("request-light");
const path = require("upath");
const html = require("vscode-html-languageservice");
const vscode = require("vscode-languageserver/node");
const commonServer_1 = require("./commonServer");
const file_1 = require("./schemaRequestHandlers/file");
const http_1 = require("./schemaRequestHandlers/http");
const nodeFileSystemHost_1 = require("./utils/nodeFileSystemHost");
const connection = vscode.createConnection(vscode.ProposedFeatures.all);
(0, commonServer_1.createLanguageServer)(connection, {
    loadTypescript(options) {
        return require(path.toUnix(options.typescript.serverPath));
    },
    loadTypescriptLocalized(options) {
        if (options.typescript.localizedPath) {
            try {
                return require(path.toUnix(options.typescript.localizedPath));
            }
            catch (_a) { }
        }
    },
    schemaRequestHandlers: {
        file: file_1.default,
        http: http_1.default,
        https: http_1.default,
    },
    onDidChangeConfiguration(settings) {
        (0, request_light_1.configure)(settings.http && settings.http.proxy, settings.http && settings.http.proxyStrictSSL);
    },
    createFileSystemHost: nodeFileSystemHost_1.createNodeFileSystemHost,
    fileSystemProvide: {
        stat: (uri) => {
            return new Promise((resolve, reject) => {
                fs.stat(shared.getPathOfUri(uri), (err, stats) => {
                    if (stats) {
                        resolve({
                            type: stats.isFile() ? html.FileType.File
                                : stats.isDirectory() ? html.FileType.Directory
                                    : stats.isSymbolicLink() ? html.FileType.SymbolicLink
                                        : html.FileType.Unknown,
                            ctime: stats.ctimeMs,
                            mtime: stats.mtimeMs,
                            size: stats.size,
                        });
                    }
                    else {
                        reject(err);
                    }
                });
            });
        },
        readDirectory: (uri) => {
            return new Promise((resolve, reject) => {
                fs.readdir(shared.getPathOfUri(uri), (err, files) => {
                    if (files) {
                        resolve(files.map(file => [file, html.FileType.File]));
                    }
                    else {
                        reject(err);
                    }
                });
            });
        },
    },
});
//# sourceMappingURL=nodeServer.js.map