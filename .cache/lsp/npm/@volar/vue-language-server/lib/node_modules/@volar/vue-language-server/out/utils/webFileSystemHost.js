var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWebFileSystemHost = void 0;
const vscode = require("vscode-languageserver");
const vscode_html_languageservice_1 = require("vscode-html-languageservice");
const vscode_uri_1 = require("vscode-uri");
const path_1 = require("path");
const requests_1 = require("../requests");
const utilities_1 = require("./ts/utilities");
let currentCwd = '/';
function createWebFileSystemHost() {
    const onDidChangeWatchedFilesCb = new Set();
    const root = {
        dirs: new Map(),
        fileTexts: new Map(),
        fileTypes: new Map(),
        searched: false,
    };
    const pendings = new Set();
    const changes = [];
    const onReadys = [];
    let checking = false;
    let connection;
    return {
        ready(_connection) {
            connection = _connection;
            connection.onDidChangeWatchedFiles(params => {
                for (const change of params.changes) {
                    const fsPath = vscode_uri_1.URI.parse(change.uri).fsPath;
                    const dir = getDir(path_1.posix.dirname(fsPath));
                    const name = path_1.posix.basename(fsPath);
                    if (change.type === vscode.FileChangeType.Created) {
                        dir.fileTypes.set(name, vscode_html_languageservice_1.FileType.File);
                    }
                    else if (change.type === vscode.FileChangeType.Changed) {
                        dir.fileTexts.delete(name);
                    }
                    else {
                        dir.fileTypes.delete(name);
                        dir.fileTexts.delete(name);
                    }
                }
                fireChanges(params, 'lsp');
            });
            for (const cb of onReadys) {
                cb(connection);
            }
            onReadys.length = 0;
        },
        clearCache() {
            root.dirs.clear();
            root.fileTexts.clear();
            root.fileTypes.clear();
            root.searched = false;
        },
        getWorkspaceFileSystem(rootUri) {
            return {
                newLine: '\n',
                useCaseSensitiveFileNames: false,
                getCurrentDirectory: () => rootUri.fsPath,
                fileExists,
                readFile,
                readDirectory,
                getDirectories,
                resolvePath,
                realpath: path => path, // TODO: cannot implement with vscode
            };
            function resolvePath(fsPath) {
                if (currentCwd !== rootUri.fsPath) {
                    process.chdir(rootUri.fsPath);
                    currentCwd = rootUri.fsPath;
                }
                return path_1.posix.resolve(fsPath);
            }
            function fileExists(fsPath) {
                fsPath = resolvePath(fsPath);
                const dir = getDir(path_1.posix.dirname(fsPath));
                const name = path_1.posix.basename(fsPath);
                if (dir.fileTypes.has(name)) {
                    return dir.fileTypes.get(name) === vscode_html_languageservice_1.FileType.File || dir.fileTypes.get(name) === vscode_html_languageservice_1.FileType.SymbolicLink;
                }
                dir.fileTypes.set(name, undefined);
                if (connection) {
                    addPending(statAsync(connection, fsPath, dir));
                }
                else {
                    onReadys.push((connection) => addPending(statAsync(connection, fsPath, dir)));
                }
                return false;
            }
            function readFile(fsPath) {
                fsPath = resolvePath(fsPath);
                const dir = getDir(path_1.posix.dirname(fsPath));
                const name = path_1.posix.basename(fsPath);
                if (dir.fileTexts.has(name)) {
                    return dir.fileTexts.get(name);
                }
                dir.fileTexts.set(name, '');
                if (connection) {
                    addPending(readFileAsync(connection, fsPath, dir));
                }
                else {
                    onReadys.push((connection) => addPending(readFileAsync(connection, fsPath, dir)));
                }
                return '';
            }
            function readDirectory(fsPath, extensions, exclude, include, depth) {
                fsPath = resolvePath(fsPath);
                return (0, utilities_1.matchFiles)(fsPath, extensions, exclude, include, false, rootUri.fsPath, depth, dirPath => {
                    dirPath = resolvePath(dirPath);
                    const dir = getDir(dirPath);
                    const files = [...dir.fileTypes];
                    if (!dir.searched) {
                        dir.searched = true;
                        if (connection) {
                            addPending(readDirectoryAsync(connection, dirPath, dir));
                        }
                        else {
                            onReadys.push((connection) => addPending(readDirectoryAsync(connection, dirPath, dir)));
                        }
                    }
                    return {
                        files: files.filter(file => file[1] === vscode_html_languageservice_1.FileType.File).map(file => file[0]),
                        directories: files.filter(file => file[1] === vscode_html_languageservice_1.FileType.Directory).map(file => file[0]),
                    };
                }, path => path);
            }
            // for import path completion
            function getDirectories(fsPath) {
                fsPath = resolvePath(fsPath);
                const dir = getDir(fsPath);
                const files = [...dir.fileTypes];
                if (!dir.searched) {
                    dir.searched = true;
                    if (connection) {
                        addPending(readDirectoryAsync(connection, fsPath, dir));
                    }
                    else {
                        onReadys.push((connection) => addPending(readDirectoryAsync(connection, fsPath, dir)));
                    }
                }
                return files.filter(file => file[1] === vscode_html_languageservice_1.FileType.Directory).map(file => file[0]);
            }
            function getFsPathUri(fsPath) {
                return vscode_uri_1.URI.file(fsPath).with({
                    scheme: rootUri.scheme,
                    authority: rootUri.authority,
                });
            }
            function statAsync(connection, fsPath, dir) {
                return __awaiter(this, void 0, void 0, function* () {
                    const uri = getFsPathUri(fsPath);
                    const result = yield connection.sendRequest(requests_1.FsStatRequest.type, uri.toString());
                    if ((result === null || result === void 0 ? void 0 : result.type) === vscode_html_languageservice_1.FileType.File || (result === null || result === void 0 ? void 0 : result.type) === vscode_html_languageservice_1.FileType.SymbolicLink) {
                        const name = path_1.posix.basename(fsPath);
                        dir.fileTypes.set(name, result.type);
                        changes.push({
                            uri: uri.toString(),
                            type: vscode.FileChangeType.Created,
                        });
                    }
                });
            }
            function readFileAsync(connection, fsPath, dir) {
                return __awaiter(this, void 0, void 0, function* () {
                    const uri = getFsPathUri(fsPath);
                    const text = yield connection.sendRequest(requests_1.FsReadFileRequest.type, uri.toString());
                    if (text) {
                        const name = path_1.posix.basename(fsPath);
                        dir.fileTexts.set(name, text);
                        changes.push({
                            uri: uri.toString(),
                            type: vscode.FileChangeType.Changed,
                        });
                    }
                });
            }
            function readDirectoryAsync(connection, fsPath, dir) {
                return __awaiter(this, void 0, void 0, function* () {
                    const uri = getFsPathUri(fsPath);
                    const result = yield connection.sendRequest(requests_1.FsReadDirectoryRequest.type, uri.toString());
                    for (const [name, fileType] of result) {
                        if (dir.fileTypes.get(name) !== fileType && (fileType === vscode_html_languageservice_1.FileType.File || fileType === vscode_html_languageservice_1.FileType.SymbolicLink)) {
                            changes.push({
                                uri: getFsPathUri(path_1.posix.join(fsPath, name)).toString(),
                                type: vscode.FileChangeType.Created,
                            });
                        }
                        dir.fileTypes.set(name, fileType);
                    }
                });
            }
        },
        onDidChangeWatchedFiles: cb => {
            onDidChangeWatchedFilesCb.add(cb);
            return () => onDidChangeWatchedFilesCb.delete(cb);
        },
    };
    function addPending(p) {
        return __awaiter(this, void 0, void 0, function* () {
            pendings.add(p);
            if (checking === false) {
                checking = true;
                while (pendings.size > 0) {
                    const _pendings = [...pendings];
                    pendings.clear();
                    yield Promise.all(_pendings);
                }
                if (changes.length) {
                    fireChanges({ changes: [...changes] }, 'web-cache-updated');
                    changes.length = 0;
                }
                checking = false;
            }
        });
    }
    function fireChanges(params, reason) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const cb of [...onDidChangeWatchedFilesCb]) {
                if (onDidChangeWatchedFilesCb.has(cb)) {
                    yield cb(params, reason);
                }
            }
        });
    }
    function getDir(dirPath) {
        const dirNames = [];
        let currentDirPath = dirPath;
        let currentDirName = path_1.posix.basename(currentDirPath);
        while (currentDirName !== '') {
            dirNames.push(currentDirName);
            currentDirPath = path_1.posix.dirname(currentDirPath);
            currentDirName = path_1.posix.basename(currentDirPath);
        }
        let currentDir = root;
        for (let i = dirNames.length - 1; i >= 0; i--) {
            const nextDirName = dirNames[i];
            currentDir = getDirFromDir(currentDir, nextDirName);
        }
        return currentDir;
    }
    function getDirFromDir(dir, name) {
        let target = dir.dirs.get(name);
        if (!target) {
            target = {
                dirs: new Map(),
                fileTexts: new Map(),
                fileTypes: new Map(),
                searched: false,
            };
            dir.dirs.set(name, target);
        }
        return target;
    }
}
exports.createWebFileSystemHost = createWebFileSystemHost;
//# sourceMappingURL=webFileSystemHost.js.map