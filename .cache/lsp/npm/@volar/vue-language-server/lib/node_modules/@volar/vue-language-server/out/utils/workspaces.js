var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWorkspaces = void 0;
const shared = require("@volar/shared");
const vscode_uri_1 = require("vscode-uri");
const workspaceProjects_1 = require("./workspaceProjects");
function createWorkspaces(runtimeEnv, languageConfigs, fsHost, configurationHost, ts, tsLocalized, options, documents, connection) {
    var _a;
    let semanticTokensReq = 0;
    let documentUpdatedReq = 0;
    const workspaces = new Map();
    documents.onDidOpen(params => {
        updateDiagnostics(params.textDocument.uri);
    });
    documents.onDidChangeContent((params) => __awaiter(this, void 0, void 0, function* () {
        updateDiagnostics(params.textDocument.uri);
    }));
    documents.onDidClose(params => {
        connection.sendDiagnostics({ uri: params.textDocument.uri, diagnostics: [] });
    });
    fsHost.onDidChangeWatchedFiles(params => {
        const tsConfigChanges = params.changes.filter(change => workspaceProjects_1.rootTsConfigNames.includes(change.uri.substring(change.uri.lastIndexOf('/') + 1)));
        if (tsConfigChanges.length) {
            for (const doc of documents.data.values()) {
                connection.sendDiagnostics({ uri: doc.uri, diagnostics: [] });
            }
        }
        onDriveFileUpdated();
    });
    (_a = runtimeEnv.onDidChangeConfiguration) === null || _a === void 0 ? void 0 : _a.call(runtimeEnv, () => __awaiter(this, void 0, void 0, function* () {
        onDriveFileUpdated();
    }));
    return {
        workspaces,
        getProject,
        reloadProject,
        add: (rootUri) => {
            workspaces.set(rootUri.toString(), (0, workspaceProjects_1.createWorkspaceProjects)(runtimeEnv, languageConfigs, fsHost, rootUri, ts, tsLocalized, options, documents, connection, configurationHost));
        },
        remove: (rootUri) => {
            const _workspace = workspaces.get(rootUri.toString());
            workspaces.delete(rootUri.toString());
            (() => __awaiter(this, void 0, void 0, function* () {
                var _a;
                (_a = (yield _workspace)) === null || _a === void 0 ? void 0 : _a.dispose();
            }))();
        },
    };
    function reloadProject() {
        return __awaiter(this, void 0, void 0, function* () {
            fsHost.clearCache();
            for (const [_, workspace] of workspaces) {
                (yield workspace).reload();
            }
        });
    }
    function onDriveFileUpdated() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const req = ++semanticTokensReq;
            yield updateDiagnostics();
            if (req === semanticTokensReq) {
                if ((_a = options.languageFeatures) === null || _a === void 0 ? void 0 : _a.semanticTokens) {
                    connection.languages.semanticTokens.refresh();
                }
                if ((_b = options.languageFeatures) === null || _b === void 0 ? void 0 : _b.inlayHints) {
                    connection.languages.semanticTokens.refresh();
                }
            }
        });
    }
    function updateDiagnostics(docUri) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!((_a = options.languageFeatures) === null || _a === void 0 ? void 0 : _a.diagnostics))
                return;
            const req = ++documentUpdatedReq;
            const delay = yield (configurationHost === null || configurationHost === void 0 ? void 0 : configurationHost.getConfiguration('volar.diagnostics.delay'));
            const cancel = {
                get isCancellationRequested() {
                    return req !== documentUpdatedReq;
                },
                // @ts-ignore
                onCancellationRequested: undefined,
            };
            const changeDoc = docUri ? documents.data.uriGet(docUri) : undefined;
            const otherDocs = [...documents.data.values()].filter(doc => doc !== changeDoc);
            if (changeDoc) {
                yield shared.sleep(delay !== null && delay !== void 0 ? delay : 200);
                yield sendDocumentDiagnostics(changeDoc.uri, changeDoc.version, cancel);
            }
            for (const doc of otherDocs) {
                yield shared.sleep(delay !== null && delay !== void 0 ? delay : 200);
                yield sendDocumentDiagnostics(doc.uri, doc.version, cancel);
                if (cancel.isCancellationRequested) {
                    break;
                }
            }
            function sendDocumentDiagnostics(uri, version, cancel) {
                var _a;
                return __awaiter(this, void 0, void 0, function* () {
                    const project = (_a = (yield getProject(uri))) === null || _a === void 0 ? void 0 : _a.project;
                    if (!project)
                        return;
                    const languageService = project.getLanguageService();
                    const errors = yield languageService.doValidation(uri, result => {
                        connection.sendDiagnostics({ uri: uri, diagnostics: result.map(addVersion), version });
                    }, cancel);
                    connection.sendDiagnostics({ uri: uri, diagnostics: errors.map(addVersion), version });
                    function addVersion(error) {
                        if (error.data === undefined) {
                            error.data = { version };
                        }
                        else if (typeof error.data === 'object') {
                            error.data.version = version;
                        }
                        return error;
                    }
                });
            }
        });
    }
    function getProject(uri) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const rootUris = [...workspaces.keys()]
                .filter(rootUri => shared.isFileInDir(vscode_uri_1.URI.parse(uri).fsPath, vscode_uri_1.URI.parse(rootUri).fsPath))
                .sort((a, b) => (0, workspaceProjects_1.sortTsConfigs)(vscode_uri_1.URI.parse(uri).fsPath, vscode_uri_1.URI.parse(a).fsPath, vscode_uri_1.URI.parse(b).fsPath));
            for (const rootUri of rootUris) {
                const workspace = yield workspaces.get(rootUri);
                const project = yield (workspace === null || workspace === void 0 ? void 0 : workspace.getProjectAndTsConfig(uri));
                if (project) {
                    return project;
                }
            }
            if (rootUris.length) {
                return {
                    tsconfig: undefined,
                    project: yield ((_a = (yield workspaces.get(rootUris[0]))) === null || _a === void 0 ? void 0 : _a.getInferredProject()),
                };
            }
        });
    }
}
exports.createWorkspaces = createWorkspaces;
//# sourceMappingURL=workspaces.js.map