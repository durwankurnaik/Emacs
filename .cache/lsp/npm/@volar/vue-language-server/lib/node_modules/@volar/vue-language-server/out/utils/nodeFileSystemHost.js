var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNodeFileSystemHost = void 0;
const vscode = require("vscode-languageserver");
const iterableWeakSet_1 = require("./iterableWeakSet");
let currentCwd = '';
function createNodeFileSystemHost(ts, capabilities) {
    const onDidChangeWatchedFilesCb = new Set();
    const caches = new iterableWeakSet_1.IterableWeakSet();
    return {
        ready(connection) {
            connection.onDidChangeWatchedFiles((params) => __awaiter(this, void 0, void 0, function* () {
                if (params.changes.some(change => change.type === vscode.FileChangeType.Created || change.type === vscode.FileChangeType.Deleted)) {
                    caches.forEach(cache => {
                        cache.clear();
                    });
                }
                for (const cb of [...onDidChangeWatchedFilesCb]) {
                    if (onDidChangeWatchedFilesCb.has(cb)) {
                        yield cb(params, 'lsp');
                    }
                }
            }));
        },
        clearCache() {
            caches.forEach(cache => {
                cache.clear();
            });
        },
        getWorkspaceFileSystem(rootUri) {
            var _a;
            const workspaceSys = new Proxy(ts.sys, {
                get(target, prop) {
                    const fn = target[prop];
                    if (typeof fn === 'function') {
                        return new Proxy(fn, {
                            apply(target, thisArg, args) {
                                if (currentCwd !== rootUri.fsPath) {
                                    process.chdir(rootUri.fsPath);
                                    currentCwd = rootUri.fsPath;
                                }
                                return target.apply(thisArg, args);
                            }
                        });
                    }
                    return fn;
                },
            });
            const fileExistsCache = new Map();
            const directoryExistsCache = new Map();
            const sysWithCache = {
                fileExists(path) {
                    if (!fileExistsCache.has(path)) {
                        fileExistsCache.set(path, ts.sys.fileExists(path));
                    }
                    return fileExistsCache.get(path);
                },
                directoryExists(path) {
                    if (!directoryExistsCache.has(path)) {
                        directoryExistsCache.set(path, ts.sys.directoryExists(path));
                    }
                    return directoryExistsCache.get(path);
                },
            };
            // don't cache fs result if client did not supports file watcher
            const sys = ((_a = capabilities.workspace) === null || _a === void 0 ? void 0 : _a.didChangeWatchedFiles)
                ? new Proxy(workspaceSys, {
                    get(target, prop) {
                        if (prop in sysWithCache) {
                            return sysWithCache[prop];
                        }
                        return target[prop];
                    },
                })
                : workspaceSys;
            caches.add(fileExistsCache);
            caches.add(directoryExistsCache);
            return sys;
        },
        onDidChangeWatchedFiles: cb => {
            onDidChangeWatchedFilesCb.add(cb);
            return () => onDidChangeWatchedFilesCb.delete(cb);
        },
    };
}
exports.createNodeFileSystemHost = createNodeFileSystemHost;
//# sourceMappingURL=nodeFileSystemHost.js.map