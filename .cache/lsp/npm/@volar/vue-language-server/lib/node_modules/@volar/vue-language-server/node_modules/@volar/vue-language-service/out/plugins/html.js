var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isNewlineCharacter = void 0;
const vue_language_service_types_1 = require("@volar/vue-language-service-types");
const html = require("vscode-html-languageservice");
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const shared = require("@volar/shared");
const vscode = require("vscode-languageserver-protocol");
function default_1(options) {
    const htmlDocuments = new WeakMap();
    const htmlLs = html.getLanguageService({ fileSystemProvider: options.fileSystemProvider });
    let inited = false;
    let customData = [];
    let extraData = [];
    return {
        htmlLs,
        getHtmlDocument,
        updateCustomData,
        complete: {
            // https://github.com/microsoft/vscode/blob/09850876e652688fb142e2e19fd00fd38c0bc4ba/extensions/html-language-features/server/src/htmlServer.ts#L183
            triggerCharacters: ['.', ':', '<', '"', '=', '/'],
            on(document, position, context) {
                return __awaiter(this, void 0, void 0, function* () {
                    return worker(document, (htmlDocument) => __awaiter(this, void 0, void 0, function* () {
                        var _a;
                        const configs = yield ((_a = (0, vue_language_service_types_1.useConfigurationHost)()) === null || _a === void 0 ? void 0 : _a.getConfiguration('html.completion', document.uri));
                        if (options.documentContext) {
                            return htmlLs.doComplete2(document, position, htmlDocument, options.documentContext, configs);
                        }
                        else {
                            return htmlLs.doComplete(document, position, htmlDocument, configs);
                        }
                    }));
                });
            },
        },
        rename: {
            on(document, position, newName) {
                return worker(document, (htmlDocument) => {
                    return htmlLs.doRename(document, position, newName, htmlDocument);
                });
            },
        },
        doHover(document, position) {
            return __awaiter(this, void 0, void 0, function* () {
                return worker(document, (htmlDocument) => __awaiter(this, void 0, void 0, function* () {
                    var _a;
                    const hoverSettings = yield ((_a = (0, vue_language_service_types_1.useConfigurationHost)()) === null || _a === void 0 ? void 0 : _a.getConfiguration('html.hover', document.uri));
                    return htmlLs.doHover(document, position, htmlDocument, hoverSettings);
                }));
            });
        },
        findDocumentHighlights(document, position) {
            return worker(document, (htmlDocument) => {
                return htmlLs.findDocumentHighlights(document, position, htmlDocument);
            });
        },
        findDocumentLinks(document) {
            return worker(document, (htmlDocument) => {
                if (!options.documentContext)
                    return;
                return htmlLs.findDocumentLinks(document, options.documentContext);
            });
        },
        findDocumentSymbols(document) {
            return worker(document, (htmlDocument) => {
                return htmlLs.findDocumentSymbols(document, htmlDocument);
            });
        },
        getFoldingRanges(document) {
            return worker(document, (htmlDocument) => {
                return htmlLs.getFoldingRanges(document);
            });
        },
        getSelectionRanges(document, positions) {
            return worker(document, (htmlDocument) => {
                return htmlLs.getSelectionRanges(document, positions);
            });
        },
        format(document, formatRange, options) {
            return __awaiter(this, void 0, void 0, function* () {
                return worker(document, (htmlDocument) => __awaiter(this, void 0, void 0, function* () {
                    var _a;
                    const options_2 = yield ((_a = (0, vue_language_service_types_1.useConfigurationHost)()) === null || _a === void 0 ? void 0 : _a.getConfiguration('html.format', document.uri));
                    if ((options_2 === null || options_2 === void 0 ? void 0 : options_2.enable) === false) {
                        return;
                    }
                    { // https://github.com/microsoft/vscode/blob/dce493cb6e36346ef2714e82c42ce14fc461b15c/extensions/html-language-features/server/src/modes/formatting.ts#L13-L23
                        const endPos = formatRange.end;
                        let endOffset = document.offsetAt(endPos);
                        const content = document.getText();
                        if (endPos.character === 0 && endPos.line > 0 && endOffset !== content.length) {
                            // if selection ends after a new line, exclude that new line
                            const prevLineStart = document.offsetAt(vscode.Position.create(endPos.line - 1, 0));
                            while (isEOL(content, endOffset - 1) && endOffset > prevLineStart) {
                                endOffset--;
                            }
                            formatRange = vscode.Range.create(formatRange.start, document.positionAt(endOffset));
                        }
                    }
                    const edits = htmlLs.format(document, formatRange, Object.assign(Object.assign({}, options_2), options));
                    const newText = vscode_languageserver_textdocument_1.TextDocument.applyEdits(document, edits);
                    return [{
                            newText: '\n' + newText.trim() + '\n',
                            range: {
                                start: document.positionAt(0),
                                end: document.positionAt(document.getText().length),
                            },
                        }];
                }));
            });
        },
        findLinkedEditingRanges(document, position) {
            return worker(document, (htmlDocument) => {
                const ranges = htmlLs.findLinkedEditingRanges(document, position, htmlDocument);
                if (!ranges)
                    return;
                return { ranges };
            });
        },
        doAutoInsert(document, position, context) {
            return __awaiter(this, void 0, void 0, function* () {
                return worker(document, (htmlDocument) => __awaiter(this, void 0, void 0, function* () {
                    var _a, _b, _c, _d, _e;
                    const lastCharacter = context.lastChange.text[context.lastChange.text.length - 1];
                    if (context.lastChange.rangeLength === 0 && lastCharacter === '=') {
                        const enabled = (_b = (yield ((_a = (0, vue_language_service_types_1.useConfigurationHost)()) === null || _a === void 0 ? void 0 : _a.getConfiguration('html.autoCreateQuotes')))) !== null && _b !== void 0 ? _b : true;
                        if (enabled) {
                            const text = htmlLs.doQuoteComplete(document, position, htmlDocument, yield ((_c = (0, vue_language_service_types_1.useConfigurationHost)()) === null || _c === void 0 ? void 0 : _c.getConfiguration('html.completion', document.uri)));
                            if (text) {
                                return text;
                            }
                        }
                    }
                    if (context.lastChange.rangeLength === 0 && (lastCharacter === '>' || lastCharacter === '/')) {
                        const enabled = (_e = (yield ((_d = (0, vue_language_service_types_1.useConfigurationHost)()) === null || _d === void 0 ? void 0 : _d.getConfiguration('html.autoClosingTags')))) !== null && _e !== void 0 ? _e : true;
                        if (enabled) {
                            const text = htmlLs.doTagComplete(document, position, htmlDocument);
                            if (text) {
                                return text;
                            }
                        }
                    }
                }));
            });
        },
    };
    function initCustomData() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!inited && !options.disableCustomData) {
                inited = true;
                (_a = (0, vue_language_service_types_1.useConfigurationHost)()) === null || _a === void 0 ? void 0 : _a.onDidChangeConfiguration(() => __awaiter(this, void 0, void 0, function* () {
                    customData = yield getCustomData();
                    htmlLs.setDataProviders(true, [...customData, ...extraData]);
                }));
                customData = yield getCustomData();
                htmlLs.setDataProviders(true, [...customData, ...extraData]);
            }
        });
    }
    function updateCustomData(data) {
        extraData = data;
        htmlLs.setDataProviders(true, [...customData, ...extraData]);
    }
    function getCustomData() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const configHost = (0, vue_language_service_types_1.useConfigurationHost)();
            if (configHost) {
                const paths = new Set();
                const customData = (_a = yield configHost.getConfiguration('html.customData')) !== null && _a !== void 0 ? _a : [];
                const rootPaths = configHost.rootUris.map(shared.getPathOfUri);
                for (const customDataPath of customData) {
                    try {
                        const jsonPath = require.resolve(customDataPath, { paths: rootPaths });
                        paths.add(jsonPath);
                    }
                    catch (error) {
                        console.error(error);
                    }
                }
                const newData = [];
                for (const path of paths) {
                    try {
                        newData.push(html.newHTMLDataProvider(path, require(path)));
                    }
                    catch (error) {
                        console.error(error);
                    }
                }
                return newData;
            }
            return [];
        });
    }
    function worker(document, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const htmlDocument = getHtmlDocument(document);
            if (!htmlDocument)
                return;
            yield initCustomData();
            return callback(htmlDocument);
        });
    }
    function getHtmlDocument(document) {
        var _a;
        if (document.languageId !== ((_a = options.validLang) !== null && _a !== void 0 ? _a : 'html'))
            return;
        const cache = htmlDocuments.get(document);
        if (cache) {
            const [cacheVersion, cacheDoc] = cache;
            if (cacheVersion === document.version) {
                return cacheDoc;
            }
        }
        const doc = htmlLs.parseHTMLDocument(document);
        htmlDocuments.set(document, [document.version, doc]);
        return doc;
    }
}
exports.default = default_1;
function isEOL(content, offset) {
    return isNewlineCharacter(content.charCodeAt(offset));
}
const CR = '\r'.charCodeAt(0);
const NL = '\n'.charCodeAt(0);
function isNewlineCharacter(charCode) {
    return charCode === CR || charCode === NL;
}
exports.isNewlineCharacter = isNewlineCharacter;
//# sourceMappingURL=html.js.map