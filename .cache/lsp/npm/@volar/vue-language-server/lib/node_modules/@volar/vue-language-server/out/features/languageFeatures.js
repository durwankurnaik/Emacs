var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = void 0;
const vue = require("@volar/vue-language-service");
const vscode = require("vscode-languageserver");
const requests_1 = require("../requests");
function register(connection, projects, features, params) {
    connection.onCompletion((handler) => __awaiter(this, void 0, void 0, function* () {
        return worker(handler.textDocument.uri, (vueLs) => __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            const list = yield vueLs.doComplete(handler.textDocument.uri, handler.position, handler.context);
            const insertReplaceSupport = (_d = (_c = (_b = (_a = params.capabilities.textDocument) === null || _a === void 0 ? void 0 : _a.completion) === null || _b === void 0 ? void 0 : _b.completionItem) === null || _c === void 0 ? void 0 : _c.insertReplaceSupport) !== null && _d !== void 0 ? _d : false;
            if (!insertReplaceSupport && list) {
                for (const item of list.items) {
                    if (item.textEdit && vscode.InsertReplaceEdit.is(item.textEdit)) {
                        item.textEdit = vscode.TextEdit.replace(item.textEdit.insert, item.textEdit.newText);
                    }
                }
            }
            return list;
        }));
    }));
    connection.onCompletionResolve((item) => __awaiter(this, void 0, void 0, function* () {
        var _e, _f, _g, _h, _j, _k, _l;
        const uri = (_e = item.data) === null || _e === void 0 ? void 0 : _e.uri;
        if (!uri) {
            return item;
        }
        const activeSel = ((_f = features.completion) === null || _f === void 0 ? void 0 : _f.getDocumentSelectionRequest)
            ? yield connection.sendRequest(requests_1.GetEditorSelectionRequest.type)
            : undefined;
        const newPosition = (activeSel === null || activeSel === void 0 ? void 0 : activeSel.textDocument.uri.toLowerCase()) === uri.toLowerCase() ? activeSel.position : undefined;
        const result = (_g = yield worker(uri, (vueLs) => __awaiter(this, void 0, void 0, function* () {
            var _m;
            return (_m = vueLs.doCompletionResolve(item, newPosition)) !== null && _m !== void 0 ? _m : item;
        }))) !== null && _g !== void 0 ? _g : item;
        const insertReplaceSupport = (_l = (_k = (_j = (_h = params.capabilities.textDocument) === null || _h === void 0 ? void 0 : _h.completion) === null || _j === void 0 ? void 0 : _j.completionItem) === null || _k === void 0 ? void 0 : _k.insertReplaceSupport) !== null && _l !== void 0 ? _l : false;
        if (!insertReplaceSupport) {
            if (result.textEdit && vscode.InsertReplaceEdit.is(result.textEdit)) {
                result.textEdit = vscode.TextEdit.replace(result.textEdit.insert, result.textEdit.newText);
            }
        }
        return result;
    }));
    connection.onHover((handler) => __awaiter(this, void 0, void 0, function* () {
        return worker(handler.textDocument.uri, vueLs => {
            return vueLs.doHover(handler.textDocument.uri, handler.position);
        });
    }));
    connection.onSignatureHelp((handler) => __awaiter(this, void 0, void 0, function* () {
        return worker(handler.textDocument.uri, vueLs => {
            return vueLs.getSignatureHelp(handler.textDocument.uri, handler.position, handler.context);
        });
    }));
    connection.onPrepareRename((handler) => __awaiter(this, void 0, void 0, function* () {
        return worker(handler.textDocument.uri, vueLs => {
            return vueLs.prepareRename(handler.textDocument.uri, handler.position);
        });
    }));
    connection.onRenameRequest((handler) => __awaiter(this, void 0, void 0, function* () {
        return worker(handler.textDocument.uri, vueLs => {
            return vueLs.doRename(handler.textDocument.uri, handler.position, handler.newName);
        });
    }));
    connection.onCodeLens((handler) => __awaiter(this, void 0, void 0, function* () {
        return worker(handler.textDocument.uri, vueLs => {
            return vueLs.doCodeLens(handler.textDocument.uri);
        });
    }));
    connection.onCodeLensResolve((codeLens) => __awaiter(this, void 0, void 0, function* () {
        var _o, _p;
        const uri = (_o = codeLens.data) === null || _o === void 0 ? void 0 : _o.uri; // TODO
        if (!uri) {
            return codeLens;
        }
        return (_p = yield worker(uri, vueLs => {
            var _a;
            return (_a = vueLs.doCodeLensResolve(codeLens)) !== null && _a !== void 0 ? _a : codeLens;
        })) !== null && _p !== void 0 ? _p : codeLens;
    }));
    connection.onExecuteCommand((handler, token, workDoneProgress) => __awaiter(this, void 0, void 0, function* () {
        if (handler.command === vue.executePluginCommand) {
            const args = handler.arguments;
            if (!args) {
                return;
            }
            return worker(args[0], vueLs => {
                return vueLs.doExecuteCommand(handler.command, args, {
                    token,
                    workDoneProgress,
                    applyEdit: (paramOrEdit) => connection.workspace.applyEdit(paramOrEdit),
                    showReferences: (params) => connection.sendNotification(requests_1.ShowReferencesNotification.type, params),
                });
            });
        }
        if (handler.command === 'volar.server.convertTagNameCasing') {
            const args = handler.arguments;
            if (!args) {
                return;
            }
            return worker(args[0], vueLs => {
                return vueLs.doExecuteCommand(vue.executePluginCommand, [
                    args[0],
                    undefined,
                    vscode.Command.create('', vue.convertTagNameCasingCommand, ...[
                        args[0],
                        args[1],
                    ]),
                ], {
                    token,
                    workDoneProgress,
                    applyEdit: (paramOrEdit) => connection.workspace.applyEdit(paramOrEdit),
                    showReferences: (params) => connection.sendNotification(requests_1.ShowReferencesNotification.type, params),
                });
            });
        }
    }));
    connection.onCodeAction((handler) => __awaiter(this, void 0, void 0, function* () {
        return worker(handler.textDocument.uri, (vueLs) => __awaiter(this, void 0, void 0, function* () {
            var _q, _r, _s;
            let codeActions = (_q = yield vueLs.doCodeActions(handler.textDocument.uri, handler.range, handler.context)) !== null && _q !== void 0 ? _q : [];
            for (const codeAction of codeActions) {
                if (codeAction.data && typeof codeAction.data === 'object') {
                    codeAction.data.uri = handler.textDocument.uri;
                }
                else {
                    codeAction.data = { uri: handler.textDocument.uri };
                }
            }
            if (!((_s = (_r = params.capabilities.textDocument) === null || _r === void 0 ? void 0 : _r.codeAction) === null || _s === void 0 ? void 0 : _s.disabledSupport)) {
                codeActions = codeActions.filter(codeAction => !codeAction.disabled);
            }
            return codeActions;
        }));
    }));
    connection.onCodeActionResolve((codeAction) => __awaiter(this, void 0, void 0, function* () {
        var _t, _u;
        const uri = (_t = codeAction.data) === null || _t === void 0 ? void 0 : _t.uri;
        if (!uri) {
            return codeAction;
        }
        return (_u = yield worker(uri, vueLs => {
            return vueLs.doCodeActionResolve(codeAction);
        })) !== null && _u !== void 0 ? _u : codeAction;
    }));
    connection.onReferences((handler) => __awaiter(this, void 0, void 0, function* () {
        return worker(handler.textDocument.uri, vueLs => {
            return vueLs.findReferences(handler.textDocument.uri, handler.position);
        });
    }));
    connection.onRequest(requests_1.FindFileReferenceRequest.type, (handler) => __awaiter(this, void 0, void 0, function* () {
        return worker(handler.textDocument.uri, vueLs => {
            return vueLs.findFileReferences(handler.textDocument.uri);
        });
    }));
    connection.onImplementation((handler) => __awaiter(this, void 0, void 0, function* () {
        return worker(handler.textDocument.uri, vueLs => {
            return vueLs.findImplementations(handler.textDocument.uri, handler.position);
        });
    }));
    connection.onDefinition((handler) => __awaiter(this, void 0, void 0, function* () {
        return worker(handler.textDocument.uri, vueLs => {
            return vueLs.findDefinition(handler.textDocument.uri, handler.position);
        });
    }));
    connection.onTypeDefinition((handler) => __awaiter(this, void 0, void 0, function* () {
        return worker(handler.textDocument.uri, vueLs => {
            return vueLs.findTypeDefinition(handler.textDocument.uri, handler.position);
        });
    }));
    connection.onDocumentHighlight((handler) => __awaiter(this, void 0, void 0, function* () {
        return worker(handler.textDocument.uri, vueLs => {
            return vueLs.findDocumentHighlights(handler.textDocument.uri, handler.position);
        });
    }));
    connection.onDocumentLinks((handler) => __awaiter(this, void 0, void 0, function* () {
        return worker(handler.textDocument.uri, vueLs => {
            return vueLs.findDocumentLinks(handler.textDocument.uri);
        });
    }));
    connection.onWorkspaceSymbol((handler, token) => __awaiter(this, void 0, void 0, function* () {
        let results = [];
        for (const _workspace of projects.workspaces.values()) {
            const workspace = yield _workspace;
            let projects = [...workspace.projects.values()];
            projects = projects.length ? projects : [workspace.getInferredProject()];
            for (const project of projects) {
                if (token.isCancellationRequested)
                    return;
                const vueLs = (yield project).getLanguageService();
                results = results.concat(yield vueLs.findWorkspaceSymbols(handler.query));
            }
        }
        return results;
    }));
    connection.languages.callHierarchy.onPrepare((handler) => __awaiter(this, void 0, void 0, function* () {
        var _v;
        return (_v = yield worker(handler.textDocument.uri, (vueLs) => __awaiter(this, void 0, void 0, function* () {
            const items = yield vueLs.callHierarchy.doPrepare(handler.textDocument.uri, handler.position);
            if (items) {
                for (const item of items) {
                    if (typeof item.data !== 'object')
                        item.data = {};
                    item.data.__uri = handler.textDocument.uri;
                }
            }
            return (items === null || items === void 0 ? void 0 : items.length) ? items : null;
        }))) !== null && _v !== void 0 ? _v : [];
    }));
    connection.languages.callHierarchy.onIncomingCalls((handler) => __awaiter(this, void 0, void 0, function* () {
        var _w, _x;
        const data = handler.item.data;
        const uri = (_w = data === null || data === void 0 ? void 0 : data.__uri) !== null && _w !== void 0 ? _w : handler.item.uri;
        return (_x = yield worker(uri, vueLs => {
            return vueLs.callHierarchy.getIncomingCalls(handler.item);
        })) !== null && _x !== void 0 ? _x : [];
    }));
    connection.languages.callHierarchy.onOutgoingCalls((handler) => __awaiter(this, void 0, void 0, function* () {
        var _y, _z;
        const data = handler.item.data;
        const uri = (_y = data === null || data === void 0 ? void 0 : data.__uri) !== null && _y !== void 0 ? _y : handler.item.uri;
        return (_z = yield worker(uri, vueLs => {
            return vueLs.callHierarchy.getOutgoingCalls(handler.item);
        })) !== null && _z !== void 0 ? _z : [];
    }));
    connection.languages.semanticTokens.on((handler, token, _, resultProgress) => __awaiter(this, void 0, void 0, function* () {
        var _0;
        return (_0 = yield worker(handler.textDocument.uri, (vueLs) => __awaiter(this, void 0, void 0, function* () {
            var _1;
            const result = (_1 = yield (vueLs === null || vueLs === void 0 ? void 0 : vueLs.getSemanticTokens(handler.textDocument.uri, undefined, token, tokens => resultProgress === null || resultProgress === void 0 ? void 0 : resultProgress.report(buildTokens(tokens))))) !== null && _1 !== void 0 ? _1 : [];
            return buildTokens(result);
        }))) !== null && _0 !== void 0 ? _0 : buildTokens([]);
    }));
    connection.languages.semanticTokens.onRange((handler, token, _, resultProgress) => __awaiter(this, void 0, void 0, function* () {
        var _2;
        return (_2 = yield worker(handler.textDocument.uri, (vueLs) => __awaiter(this, void 0, void 0, function* () {
            var _3;
            const result = (_3 = yield (vueLs === null || vueLs === void 0 ? void 0 : vueLs.getSemanticTokens(handler.textDocument.uri, handler.range, token, tokens => resultProgress === null || resultProgress === void 0 ? void 0 : resultProgress.report(buildTokens(tokens))))) !== null && _3 !== void 0 ? _3 : [];
            return buildTokens(result);
        }))) !== null && _2 !== void 0 ? _2 : buildTokens([]);
    }));
    connection.languages.diagnostics.on((params, cancellationToken, workDoneProgressReporter, resultProgressReporter) => __awaiter(this, void 0, void 0, function* () {
        const result = yield worker(params.textDocument.uri, vueLs => {
            return vueLs.doValidation(params.textDocument.uri, errors => {
                // resultProgressReporter is undefined in vscode
                resultProgressReporter === null || resultProgressReporter === void 0 ? void 0 : resultProgressReporter.report({
                    relatedDocuments: {
                        [params.textDocument.uri]: {
                            kind: vscode.DocumentDiagnosticReportKind.Full,
                            items: errors,
                        },
                    },
                });
            }, cancellationToken);
        });
        return {
            kind: vscode.DocumentDiagnosticReportKind.Full,
            items: result !== null && result !== void 0 ? result : [],
        };
    }));
    connection.languages.inlayHint.on((handler) => __awaiter(this, void 0, void 0, function* () {
        return worker(handler.textDocument.uri, vueLs => {
            return vueLs.getInlayHints(handler.textDocument.uri, handler.range);
        });
    }));
    connection.workspace.onWillRenameFiles((handler) => __awaiter(this, void 0, void 0, function* () {
        var _4;
        const config = yield connection.workspace.getConfiguration('volar.updateImportsOnFileMove.enabled');
        if (!config) {
            return null;
        }
        if (handler.files.length !== 1) {
            return null;
        }
        const file = handler.files[0];
        return (_4 = yield worker(file.oldUri, vueLs => {
            var _a;
            return (_a = vueLs.getEditsForFileRename(file.oldUri, file.newUri)) !== null && _a !== void 0 ? _a : null;
        })) !== null && _4 !== void 0 ? _4 : null;
    }));
    connection.onRequest(requests_1.AutoInsertRequest.type, (handler) => __awaiter(this, void 0, void 0, function* () {
        return worker(handler.textDocument.uri, vueLs => {
            return vueLs.doAutoInsert(handler.textDocument.uri, handler.position, handler.options);
        });
    }));
    function worker(uri, cb) {
        return __awaiter(this, void 0, void 0, function* () {
            const vueLs = yield getLanguageService(uri);
            if (vueLs) {
                return cb(vueLs);
            }
        });
    }
    function buildTokens(tokens) {
        const builder = new vscode.SemanticTokensBuilder();
        const sortedTokens = tokens.sort((a, b) => a[0] - b[0] === 0 ? a[1] - b[1] : a[0] - b[0]);
        for (const token of sortedTokens) {
            builder.push(...token);
        }
        return builder.build();
    }
    function getLanguageService(uri) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const project = (_a = (yield projects.getProject(uri))) === null || _a === void 0 ? void 0 : _a.project;
            return project === null || project === void 0 ? void 0 : project.getLanguageService();
        });
    }
}
exports.register = register;
//# sourceMappingURL=languageFeatures.js.map