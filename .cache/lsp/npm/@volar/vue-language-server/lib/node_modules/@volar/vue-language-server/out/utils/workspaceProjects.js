var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sortTsConfigs = exports.createWorkspaceProjects = exports.rootTsConfigNames = void 0;
const shared = require("@volar/shared");
const path = require("upath");
const vscode = require("vscode-languageserver");
const project_1 = require("./project");
const inferredCompilerOptions_1 = require("./inferredCompilerOptions");
const vscode_uri_1 = require("vscode-uri");
exports.rootTsConfigNames = ['tsconfig.json', 'jsconfig.json'];
function createWorkspaceProjects(runtimeEnv, languageConfigs, fsHost, rootUri, ts, tsLocalized, options, documents, connection, configHost) {
    return __awaiter(this, void 0, void 0, function* () {
        let inferredProject;
        const sys = fsHost.getWorkspaceFileSystem(rootUri);
        const projects = shared.createUriMap();
        const rootTsConfigs = new Set(sys.readDirectory(rootUri.fsPath, exports.rootTsConfigNames, undefined, ['**/*']));
        const disposeWatch = fsHost.onDidChangeWatchedFiles((params, reason) => __awaiter(this, void 0, void 0, function* () {
            const disposes = [];
            for (const change of params.changes) {
                if (exports.rootTsConfigNames.includes(path.basename(change.uri))) {
                    if (change.type === vscode.FileChangeType.Created) {
                        if (shared.isFileInDir(vscode_uri_1.URI.parse(change.uri).fsPath, rootUri.fsPath)) {
                            rootTsConfigs.add(vscode_uri_1.URI.parse(change.uri).fsPath);
                        }
                    }
                    else if ((change.type === vscode.FileChangeType.Changed || change.type === vscode.FileChangeType.Deleted) && projects.uriHas(change.uri)) {
                        if (change.type === vscode.FileChangeType.Deleted) {
                            rootTsConfigs.delete(vscode_uri_1.URI.parse(change.uri).fsPath);
                        }
                        const _project = projects.uriGet(change.uri);
                        projects.uriDelete(change.uri);
                        disposes.push((() => __awaiter(this, void 0, void 0, function* () {
                            var _a;
                            (_a = (yield _project)) === null || _a === void 0 ? void 0 : _a.dispose();
                        }))());
                    }
                }
            }
            if (reason === 'web-cache-updated' && params.changes.some(change => change.uri.indexOf('/node_modules/') >= 0)) {
                clearProjects();
            }
            return Promise.all(disposes);
        }));
        return {
            projects,
            getProjectAndTsConfig,
            getInferredProject,
            reload: clearProjects,
            dispose() {
                clearProjects();
                disposeWatch();
            },
        };
        function clearProjects() {
            const _projects = [
                inferredProject,
                ...projects.values(),
            ];
            _projects.forEach((project) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                (_a = (yield project)) === null || _a === void 0 ? void 0 : _a.dispose();
            }));
            inferredProject = undefined;
            projects.clear();
        }
        function getProjectAndTsConfig(uri) {
            return __awaiter(this, void 0, void 0, function* () {
                const tsconfig = yield findMatchConfigs(vscode_uri_1.URI.parse(uri));
                if (tsconfig) {
                    const project = yield getProjectByCreate(tsconfig);
                    return {
                        tsconfig: tsconfig,
                        project,
                    };
                }
            });
        }
        function getInferredProject() {
            if (!inferredProject) {
                inferredProject = (() => __awaiter(this, void 0, void 0, function* () {
                    const inferOptions = yield (0, inferredCompilerOptions_1.getInferredCompilerOptions)(ts, configHost);
                    return (0, project_1.createProject)(runtimeEnv, languageConfigs, fsHost, sys, ts, options, rootUri, rootUri.fsPath, inferOptions, tsLocalized, documents, connection, configHost);
                }))();
            }
            return inferredProject;
        }
        function findMatchConfigs(uri) {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                yield prepareClosestootParsedCommandLine();
                return (_a = yield findDirectIncludeTsconfig()) !== null && _a !== void 0 ? _a : yield findIndirectReferenceTsconfig();
                function prepareClosestootParsedCommandLine() {
                    return __awaiter(this, void 0, void 0, function* () {
                        let matches = [];
                        for (const rootTsConfig of rootTsConfigs) {
                            if (shared.isFileInDir(uri.fsPath, path.dirname(rootTsConfig))) {
                                matches.push(rootTsConfig);
                            }
                        }
                        matches = matches.sort((a, b) => sortTsConfigs(uri.fsPath, a, b));
                        if (matches.length) {
                            yield getParsedCommandLine(matches[0]);
                        }
                    });
                }
                function findDirectIncludeTsconfig() {
                    return findTsconfig((tsconfig) => __awaiter(this, void 0, void 0, function* () {
                        const parsedCommandLine = yield getParsedCommandLine(tsconfig);
                        // use toLowerCase to fix https://github.com/johnsoncodehk/volar/issues/1125
                        const fileNames = new Set(parsedCommandLine.fileNames.map(fileName => shared.normalizeFileName(fileName.toLowerCase())));
                        return fileNames.has(shared.normalizeFileName(uri.fsPath.toLowerCase()));
                    }));
                }
                function findIndirectReferenceTsconfig() {
                    return findTsconfig((tsconfig) => __awaiter(this, void 0, void 0, function* () {
                        const project = yield projects.pathGet(rootUri, tsconfig);
                        const ls = yield (project === null || project === void 0 ? void 0 : project.getLanguageServiceDontCreate());
                        const validDoc = ls === null || ls === void 0 ? void 0 : ls.__internal__.context.getTsLs().__internal__.getValidTextDocument(uri.toString());
                        return !!validDoc;
                    }));
                }
                function findTsconfig(match) {
                    return __awaiter(this, void 0, void 0, function* () {
                        const checked = new Set();
                        for (const rootTsConfig of [...rootTsConfigs].sort((a, b) => sortTsConfigs(uri.fsPath, a, b))) {
                            const project = yield projects.pathGet(rootUri, rootTsConfig);
                            if (project) {
                                const chains = yield getReferencesChains(project.getParsedCommandLine(), rootTsConfig, []);
                                for (const chain of chains) {
                                    for (let i = chain.length - 1; i >= 0; i--) {
                                        const tsconfig = chain[i];
                                        if (checked.has(tsconfig))
                                            continue;
                                        checked.add(tsconfig);
                                        if (yield match(tsconfig)) {
                                            return tsconfig;
                                        }
                                    }
                                }
                            }
                        }
                    });
                }
                function getReferencesChains(parsedCommandLine, tsConfig, before) {
                    var _a;
                    return __awaiter(this, void 0, void 0, function* () {
                        if ((_a = parsedCommandLine.projectReferences) === null || _a === void 0 ? void 0 : _a.length) {
                            const newChains = [];
                            for (const projectReference of parsedCommandLine.projectReferences) {
                                let tsConfigPath = projectReference.path;
                                // fix https://github.com/johnsoncodehk/volar/issues/712
                                if (!sys.fileExists(tsConfigPath)) {
                                    const newTsConfigPath = path.join(tsConfigPath, 'tsconfig.json');
                                    const newJsConfigPath = path.join(tsConfigPath, 'jsconfig.json');
                                    if (sys.fileExists(newTsConfigPath)) {
                                        tsConfigPath = newTsConfigPath;
                                    }
                                    else if (sys.fileExists(newJsConfigPath)) {
                                        tsConfigPath = newJsConfigPath;
                                    }
                                }
                                const beforeIndex = before.indexOf(tsConfigPath); // cycle
                                if (beforeIndex >= 0) {
                                    newChains.push(before.slice(0, Math.max(beforeIndex, 1)));
                                }
                                else {
                                    const referenceParsedCommandLine = yield getParsedCommandLine(tsConfigPath);
                                    for (const chain of yield getReferencesChains(referenceParsedCommandLine, tsConfigPath, [...before, tsConfig])) {
                                        newChains.push(chain);
                                    }
                                }
                            }
                            return newChains;
                        }
                        else {
                            return [[...before, tsConfig]];
                        }
                    });
                }
                function getParsedCommandLine(tsConfig) {
                    return __awaiter(this, void 0, void 0, function* () {
                        const project = yield getProjectByCreate(tsConfig);
                        return project.getParsedCommandLine();
                    });
                }
            });
        }
        function getProjectByCreate(tsConfig) {
            let project = projects.pathGet(rootUri, tsConfig);
            if (!project) {
                project = (0, project_1.createProject)(runtimeEnv, languageConfigs, fsHost, sys, ts, options, rootUri, path.dirname(tsConfig), tsConfig, tsLocalized, documents, connection, configHost);
                projects.pathSet(rootUri, tsConfig, project);
            }
            return project;
        }
    });
}
exports.createWorkspaceProjects = createWorkspaceProjects;
function sortTsConfigs(fsPath, a, b) {
    const inA = shared.isFileInDir(fsPath, path.dirname(a));
    const inB = shared.isFileInDir(fsPath, path.dirname(b));
    if (inA !== inB) {
        const aWeight = inA ? 1 : 0;
        const bWeight = inB ? 1 : 0;
        return bWeight - aWeight;
    }
    const aLength = a.split('/').length;
    const bLength = b.split('/').length;
    if (aLength === bLength) {
        const aWeight = path.basename(a) === 'tsconfig.json' ? 1 : 0;
        const bWeight = path.basename(b) === 'tsconfig.json' ? 1 : 0;
        return bWeight - aWeight;
    }
    return bLength - aLength;
}
exports.sortTsConfigs = sortTsConfigs;
//# sourceMappingURL=workspaceProjects.js.map