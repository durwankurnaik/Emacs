import * as shared from '@volar/shared';
import { ConfigurationHost, EmbeddedLanguageServicePlugin } from '@volar/vue-language-service-types';
import * as vue from '@volar/vue-language-core';
import type * as ts from 'typescript/lib/tsserverlibrary';
import type * as html from 'vscode-html-languageservice';
import * as json from 'vscode-json-languageservice';
import * as vscode from 'vscode-languageserver-protocol';
import * as executeCommand from './languageFeatures/executeCommand';
import { LanguageServiceRuntimeContext } from './types';
export interface LanguageService extends ReturnType<typeof createLanguageService> {
}
export declare function getSemanticTokenLegend(): vscode.SemanticTokensLegend;
export declare function createLanguageService(vueLsHost: vue.LanguageServiceHost, fileSystemProvider: html.FileSystemProvider | undefined, schemaRequestService: json.SchemaRequestService | undefined, configurationHost: ConfigurationHost | undefined, customPlugins: EmbeddedLanguageServicePlugin[], getNameCases?: (uri: string) => Promise<{
    tag: 'both' | 'kebabCase' | 'pascalCase';
    attr: 'kebabCase' | 'camelCase';
}>, createLanguageServiceContext?: () => {
    typescriptLanguageServiceHost: ts.LanguageServiceHost;
    mapper: {
        get: (fileName: string) => vue.SourceFile;
        delete: (fileName: string) => boolean;
        has: (fileName: string) => boolean;
        set: (fileName: string, vueFile: vue.SourceFile) => vue.SourceFile;
        getFileNames: () => string[];
        getDirs: () => string[];
        getAll: () => vue.SourceFile[];
        getTeleport: (fileName: string) => vue.Teleport | undefined;
        getAllEmbeddeds: () => Generator<{
            vueFile: vue.SourceFile;
            embedded: vue.Embedded;
        }, void, unknown>;
        fromEmbeddedLocation: (fileName: string, start: number, end?: number | undefined, filter?: ((data: vue.EmbeddedFileMappingData) => boolean) | undefined, sourceMapFilter?: ((sourceMap: vue.EmbeddedFileSourceMap) => boolean) | undefined) => Generator<{
            fileName: string;
            range: {
                start: number;
                end: number;
            };
            mapped: {
                vueFile: vue.SourceFile;
                embedded: vue.Embedded;
            };
            data: vue.EmbeddedFileMappingData;
        } | {
            fileName: string;
            range: {
                start: number;
                end: number;
            };
            mapped?: undefined;
            data?: undefined;
        }, void, unknown>;
        fromEmbeddedFile: (file: vue.EmbeddedFile) => vue.SourceFile | undefined;
        fromEmbeddedFileName: (fileName: string) => {
            vueFile: vue.SourceFile;
            embedded: vue.Embedded;
        } | undefined;
    };
    plugins: {
        order?: number | undefined;
        parseSFC?(fileName: string, content: string): vue._0.SFCParseResult | undefined;
        updateSFC?(oldResult: vue._0.SFCParseResult, textChange: {
            start: number;
            end: number;
            newText: string;
        }): vue._0.SFCParseResult | undefined;
        compileSFCTemplate?(lang: string, template: string, options?: vue._0.CompilerOptions | undefined): vue._1.CodegenResult | undefined;
        updateSFCTemplate?(oldResult: vue._1.CodegenResult, textChange: {
            start: number;
            end: number;
            newText: string;
        }): vue._1.CodegenResult | undefined;
        getEmbeddedFileNames?(fileName: string, sfc: vue.Sfc): string[];
        resolveEmbeddedFile?(fileName: string, sfc: vue.Sfc, embeddedFile: vue.EmbeddedFile): void;
    }[];
}, rootUri?: shared._.URI): {
    doValidation: (uri: string, response?: ((result: html.Diagnostic[]) => void) | undefined, cancellationToken?: vscode.CancellationToken | undefined) => Promise<html.Diagnostic[]>;
    findReferences: (uri: string, position: html.Position) => Promise<html.Location[] | undefined>;
    findFileReferences: (uri: string) => Promise<html.Location[] | undefined>;
    findDefinition: (uri: string, position: html.Position) => Promise<vscode.LocationLink[] | undefined>;
    findTypeDefinition: (uri: string, position: html.Position) => Promise<vscode.LocationLink[] | undefined>;
    findImplementations: (uri: string, position: html.Position) => Promise<vscode.LocationLink[] | undefined>;
    prepareRename: (uri: string, position: html.Position) => Promise<NonNullable<html.Range | vscode.ResponseError<void> | null | undefined> | undefined>;
    doRename: (uri: string, position: html.Position, newName: string) => Promise<html.WorkspaceEdit | undefined>;
    getEditsForFileRename: (oldUri: string, newUri: string) => Promise<html.WorkspaceEdit | undefined>;
    getSemanticTokens: (uri: string, range?: html.Range | undefined, cancleToken?: vscode.CancellationToken | undefined, reportProgress?: ((tokens: import("@volar/vue-language-service-types").SemanticToken[]) => void) | undefined) => Promise<import("@volar/vue-language-service-types").SemanticToken[] | undefined> | undefined;
    doHover: (uri: string, position: html.Position) => Promise<html.Hover | undefined>;
    doComplete: (uri: string, position: html.Position, completionContext?: vscode.CompletionContext | undefined) => Promise<{
        isIncomplete: boolean;
        items: html.CompletionItem[];
    }>;
    doCodeActions: (uri: string, range: html.Range, codeActionContext: json.CodeActionContext) => Promise<json.CodeAction[] | undefined>;
    doCodeActionResolve: (item: json.CodeAction) => Promise<json.CodeAction>;
    doCompletionResolve: (item: html.CompletionItem, newPosition?: html.Position | undefined) => Promise<html.CompletionItem>;
    getSignatureHelp: (uri: string, position: html.Position, signatureHelpContext?: vscode.SignatureHelpContext | undefined) => Promise<html.SignatureHelp | undefined>;
    doCodeLens: (uri: string) => Promise<vscode.CodeLens[]>;
    doCodeLensResolve: (item: vscode.CodeLens) => Promise<vscode.CodeLens>;
    findDocumentHighlights: (uri: string, position: html.Position) => Promise<html.DocumentHighlight[] | undefined>;
    findDocumentLinks: (uri: string) => Promise<html.DocumentLink[]>;
    findWorkspaceSymbols: (query: string) => Promise<html.SymbolInformation[]>;
    doAutoInsert: (uri: string, position: html.Position, autoInsertContext: {
        lastChange: {
            range: html.Range;
            rangeOffset: number;
            rangeLength: number;
            text: string;
        };
    }) => Promise<NonNullable<string | html.TextEdit | null | undefined> | undefined>;
    doExecuteCommand: (command: string, args: executeCommand.ExecutePluginCommandArgs, executeCommandContext: import("@volar/vue-language-service-types").ExecuteCommandContext) => Promise<void>;
    getInlayHints: (uri: string, range: html.Range) => Promise<vscode.InlayHint[] | undefined>;
    callHierarchy: {
        doPrepare(uri: string, position: html.Position): Promise<vscode.CallHierarchyItem[] | undefined>;
        getIncomingCalls(item: vscode.CallHierarchyItem): Promise<vscode.CallHierarchyIncomingCall[]>;
        getOutgoingCalls(item: vscode.CallHierarchyItem): Promise<vscode.CallHierarchyOutgoingCall[]>;
    };
    dispose: () => void;
    __internal__: {
        vueRuntimeContext: {
            typescriptLanguageServiceHost: ts.LanguageServiceHost;
            mapper: {
                get: (fileName: string) => vue.SourceFile;
                delete: (fileName: string) => boolean;
                has: (fileName: string) => boolean;
                set: (fileName: string, vueFile: vue.SourceFile) => vue.SourceFile;
                getFileNames: () => string[];
                getDirs: () => string[];
                getAll: () => vue.SourceFile[];
                getTeleport: (fileName: string) => vue.Teleport | undefined;
                getAllEmbeddeds: () => Generator<{
                    vueFile: vue.SourceFile;
                    embedded: vue.Embedded;
                }, void, unknown>;
                fromEmbeddedLocation: (fileName: string, start: number, end?: number | undefined, filter?: ((data: vue.EmbeddedFileMappingData) => boolean) | undefined, sourceMapFilter?: ((sourceMap: vue.EmbeddedFileSourceMap) => boolean) | undefined) => Generator<{
                    fileName: string;
                    range: {
                        start: number;
                        end: number;
                    };
                    mapped: {
                        vueFile: vue.SourceFile;
                        embedded: vue.Embedded;
                    };
                    data: vue.EmbeddedFileMappingData;
                } | {
                    fileName: string;
                    range: {
                        start: number;
                        end: number;
                    };
                    mapped?: undefined;
                    data?: undefined;
                }, void, unknown>;
                fromEmbeddedFile: (file: vue.EmbeddedFile) => vue.SourceFile | undefined;
                fromEmbeddedFileName: (fileName: string) => {
                    vueFile: vue.SourceFile;
                    embedded: vue.Embedded;
                } | undefined;
            };
            plugins: {
                order?: number | undefined;
                parseSFC?(fileName: string, content: string): vue._0.SFCParseResult | undefined;
                updateSFC?(oldResult: vue._0.SFCParseResult, textChange: {
                    start: number;
                    end: number;
                    newText: string;
                }): vue._0.SFCParseResult | undefined;
                compileSFCTemplate?(lang: string, template: string, options?: vue._0.CompilerOptions | undefined): vue._1.CodegenResult | undefined;
                updateSFCTemplate?(oldResult: vue._1.CodegenResult, textChange: {
                    start: number;
                    end: number;
                    newText: string;
                }): vue._1.CodegenResult | undefined;
                getEmbeddedFileNames?(fileName: string, sfc: vue.Sfc): string[];
                resolveEmbeddedFile?(fileName: string, sfc: vue.Sfc, embeddedFile: vue.EmbeddedFile): void;
            }[];
        };
        rootPath: string;
        context: LanguageServiceRuntimeContext;
        getContext: () => LanguageServiceRuntimeContext;
        detectTagNameCase: (uri: string) => Promise<{
            tag: "both" | "kebabCase" | "pascalCase" | "unsure";
            attr: "kebabCase" | "unsure" | "camelCase";
        }>;
    };
};
