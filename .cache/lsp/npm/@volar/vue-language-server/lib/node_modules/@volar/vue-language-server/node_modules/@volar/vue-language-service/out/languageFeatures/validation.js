var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = exports.updateRange = void 0;
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const typescript_1 = require("../plugins/typescript");
const dedupe = require("../utils/dedupe");
const featureWorkers_1 = require("../utils/featureWorkers");
const shared = require("@volar/shared");
function updateRange(range, change) {
    updatePosition(range.start, change, false);
    updatePosition(range.end, change, true);
    if (range.end.line === range.start.line && range.end.character <= range.start.character) {
        range.end.character++;
    }
    return range;
}
exports.updateRange = updateRange;
function updatePosition(position, change, isEnd) {
    if (change.range.end.line > position.line) {
        if (change.newEnd.line > position.line) {
            // No change
        }
        else if (change.newEnd.line === position.line) {
            position.character = Math.min(position.character, change.newEnd.character);
        }
        else if (change.newEnd.line < position.line) {
            position.line = change.newEnd.line;
            position.character = change.newEnd.character;
        }
    }
    else if (change.range.end.line === position.line) {
        const characterDiff = change.newEnd.character - change.range.end.character;
        if (position.character >= change.range.end.character) {
            if (change.newEnd.line !== change.range.end.line) {
                position.line = change.newEnd.line;
                position.character = change.newEnd.character + position.character - change.range.end.character;
            }
            else {
                if (isEnd ? change.range.end.character < position.character : change.range.end.character <= position.character) {
                    position.character += characterDiff;
                }
                else {
                    const offset = change.range.end.character - position.character;
                    if (-characterDiff > offset) {
                        position.character += characterDiff + offset;
                    }
                }
            }
        }
        else {
            if (change.newEnd.line !== change.range.end.line) {
                if (change.newEnd.line < change.range.end.line) {
                    position.line = change.newEnd.line;
                    position.character = change.newEnd.character;
                }
            }
            else {
                const offset = change.range.end.character - position.character;
                if (-characterDiff > offset) {
                    position.character += characterDiff + offset;
                }
            }
        }
    }
    else if (change.range.end.line < position.line) {
        position.line += change.newEnd.line - change.range.end.line;
    }
}
function register(context) {
    const responseCache = new Map();
    const nonTsCache = new Map();
    const scriptTsCache_semantic = new Map();
    const scriptTsCache_declaration = new Map();
    const scriptTsCache_syntactic = new Map();
    const scriptTsCache_suggestion = new Map();
    return (uri, response, cancellationToken) => __awaiter(this, void 0, void 0, function* () {
        var _a;
        const cache = (_a = responseCache.get(uri)) !== null && _a !== void 0 ? _a : responseCache.set(uri, {
            nonTs: { snapshot: undefined, errors: [] },
            tsSemantic: { snapshot: undefined, errors: [] },
            tsDeclaration: { snapshot: undefined, errors: [] },
            tsSuggestion: { snapshot: undefined, errors: [] },
            tsSyntactic: { snapshot: undefined, errors: [] },
        }).get(uri);
        const newSnapshot = context.host.getScriptSnapshot(shared.getPathOfUri(uri));
        const newDocument = newSnapshot ? vscode_languageserver_textdocument_1.TextDocument.create('file://a.txt', 'txt', 0, newSnapshot.getText(0, newSnapshot.getLength())) : undefined;
        for (const _cache of Object.values(cache)) {
            const oldSnapshot = _cache.snapshot;
            const change = oldSnapshot ? newSnapshot === null || newSnapshot === void 0 ? void 0 : newSnapshot.getChangeRange(oldSnapshot) : undefined;
            _cache.snapshot = newSnapshot;
            if (newDocument && oldSnapshot && newSnapshot && change) {
                const oldDocument = vscode_languageserver_textdocument_1.TextDocument.create('file://a.txt', 'txt', 0, oldSnapshot.getText(0, oldSnapshot.getLength()));
                const changeRange = {
                    range: {
                        start: oldDocument.positionAt(change.span.start),
                        end: oldDocument.positionAt(change.span.start + change.span.length),
                    },
                    newEnd: newDocument.positionAt(change.span.start + change.newLength),
                };
                for (const error of _cache.errors) {
                    updateRange(error.range, changeRange);
                }
            }
        }
        let shouldSend = false;
        let lastCheckCancelAt = 0;
        yield worker(false, undefined, nonTsCache, cache.nonTs);
        doResponse();
        yield worker(true, { syntactic: true }, scriptTsCache_syntactic, cache.tsSyntactic);
        doResponse();
        yield worker(true, { suggestion: true }, scriptTsCache_suggestion, cache.tsSuggestion);
        doResponse();
        yield worker(true, { semantic: true }, scriptTsCache_semantic, cache.tsSemantic);
        doResponse();
        yield worker(true, { declaration: true }, scriptTsCache_declaration, cache.tsDeclaration);
        return getErrors();
        function doResponse() {
            if (shouldSend) {
                response === null || response === void 0 ? void 0 : response(getErrors());
                shouldSend = false;
            }
        }
        function getErrors() {
            return Object.values(cache).flatMap(({ errors }) => errors);
        }
        function worker(isTs, options, cacheMap, cache) {
            return __awaiter(this, void 0, void 0, function* () {
                const result = yield (0, featureWorkers_1.languageFeatureWorker)(context, uri, true, function* (arg, sourceMap) {
                    if (sourceMap.embeddedFile.capabilities.diagnostics && sourceMap.embeddedFile.isTsHostFile === isTs) {
                        yield arg;
                    }
                }, (plugin, document, arg, sourceMap) => __awaiter(this, void 0, void 0, function* () {
                    var _a, _b, _c, _d;
                    if (cancellationToken) {
                        if (Date.now() - lastCheckCancelAt >= 5) {
                            yield shared.sleep(5); // wait for LSP event polling
                            lastCheckCancelAt = Date.now();
                        }
                        if (cancellationToken.isCancellationRequested)
                            return;
                    }
                    // avoid duplicate errors from vue plugin & typescript plugin
                    if ((0, typescript_1.isTsDocument)(document) !== isTs)
                        return;
                    const pluginId = context.getPluginId(plugin);
                    const pluginCache = (_a = cacheMap.get(pluginId)) !== null && _a !== void 0 ? _a : cacheMap.set(pluginId, new Map()).get(pluginId);
                    const cache = pluginCache.get(document.uri);
                    const tsProjectVersion = isTs ? (_c = (_b = context.getTsLs().__internal__.host).getProjectVersion) === null || _c === void 0 ? void 0 : _c.call(_b) : undefined;
                    if (!isTs) {
                        if (cache && cache.documentVersion === document.version) {
                            return cache.errors;
                        }
                    }
                    else {
                        if (!options || options.declaration || options.semantic) {
                            if (cache && cache.documentVersion === document.version && cache.tsProjectVersion === tsProjectVersion) {
                                return cache.errors;
                            }
                        }
                        else {
                            if (cache && cache.documentVersion === document.version) {
                                return cache.errors;
                            }
                        }
                    }
                    const errors = yield ((_d = plugin.doValidation) === null || _d === void 0 ? void 0 : _d.call(plugin, document, options));
                    shouldSend = true;
                    pluginCache.set(document.uri, {
                        documentVersion: document.version,
                        errors,
                        tsProjectVersion,
                    });
                    return errors;
                }), (errors, sourceMap) => transformErrorRange(sourceMap, errors), arr => dedupe.withDiagnostics(arr.flat()));
                if (result) {
                    cache.errors = result;
                    cache.snapshot = newSnapshot;
                }
            });
        }
    });
    function transformErrorRange(sourceMap, errors) {
        var _a, _b, _c;
        const result = [];
        for (const error of errors) {
            const _error = Object.assign({}, error);
            if (sourceMap) {
                let sourceRange = (_a = sourceMap.getSourceRange(error.range.start, error.range.end, data => !!data.capabilities.diagnostic)) === null || _a === void 0 ? void 0 : _a[0];
                // fix https://github.com/johnsoncodehk/volar/issues/1205
                // fix https://github.com/johnsoncodehk/volar/issues/1264
                if (!sourceRange) {
                    const start = (_b = sourceMap.getSourceRange(error.range.start, error.range.start, data => !!data.capabilities.diagnostic)) === null || _b === void 0 ? void 0 : _b[0].start;
                    const end = (_c = sourceMap.getSourceRange(error.range.end, error.range.end, data => !!data.capabilities.diagnostic)) === null || _c === void 0 ? void 0 : _c[0].end;
                    if (start && end) {
                        sourceRange = { start, end };
                    }
                }
                if (!sourceRange)
                    continue;
                _error.range = sourceRange;
            }
            if (_error.relatedInformation) {
                const relatedInfos = [];
                for (const info of _error.relatedInformation) {
                    for (const sourceLoc of context.vueDocuments.fromEmbeddedLocation(info.location.uri, info.location.range.start, info.location.range.end, data => !!data.capabilities.diagnostic)) {
                        relatedInfos.push({
                            location: {
                                uri: sourceLoc.uri,
                                range: sourceLoc.range,
                            },
                            message: info.message,
                        });
                        break;
                    }
                }
                _error.relatedInformation = relatedInfos;
            }
            result.push(_error);
        }
        return result;
    }
}
exports.register = register;
//# sourceMappingURL=validation.js.map