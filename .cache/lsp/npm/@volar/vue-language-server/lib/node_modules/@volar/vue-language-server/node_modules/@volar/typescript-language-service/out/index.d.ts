import { TextDocument } from 'vscode-languageserver-textdocument';
import type * as ts from 'typescript/lib/tsserverlibrary';
import { URI } from 'vscode-uri';
import * as _ from 'vscode-languageserver-protocol';
export interface LanguageService extends ReturnType<typeof createLanguageService> {
}
export { getSemanticTokenLegend } from './services/semanticTokens';
export * from './configs/getFormatCodeSettings';
export * from './configs/getUserPreferences';
export interface GetConfiguration {
    (section: string, scopeUri: string): Promise<any>;
}
export declare function createLanguageService(ts: typeof import('typescript/lib/tsserverlibrary'), host: ts.LanguageServiceHost, languageService: ts.LanguageService, getConfiguration: GetConfiguration, rootUri: URI): {
    findDefinition: (uri: string, position: _.Position) => _.LocationLink[];
    findTypeDefinition: (uri: string, position: _.Position) => _.LocationLink[];
    findReferences: (uri: string, position: _.Position) => _.Location[];
    findFileReferences: (uri: string) => _.Location[];
    findImplementations: (uri: string, position: _.Position) => _.LocationLink[];
    prepareRename: (uri: string, position: _.Position) => _.Range | _.ResponseError<void> | undefined;
    doRename: (uri: string, position: _.Position, newName: string) => Promise<_.WorkspaceEdit | undefined>;
    getEditsForFileRename: (oldUri: string, newUri: string) => Promise<_.WorkspaceEdit | undefined>;
    getCodeActions: (uri: string, range: _.Range, context: _.CodeActionContext) => Promise<_.CodeAction[] | undefined>;
    doCodeActionResolve: (codeAction: _.CodeAction) => Promise<_.CodeAction>;
    getInlayHints: (uri: string, range: _.Range) => Promise<_.InlayHint[] | undefined>;
    findDocumentHighlights: (uri: string, position: _.Position) => _.DocumentHighlight[];
    findDocumentSymbols: (uri: string) => _.SymbolInformation[];
    findWorkspaceSymbols: (query: string) => _.SymbolInformation[];
    doComplete: (uri: string, position: _.Position, options?: ts.GetCompletionsAtPositionOptions | undefined) => Promise<_.CompletionList | undefined>;
    doCompletionResolve: (item: _.CompletionItem, newPosition?: _.Position | undefined) => Promise<_.CompletionItem>;
    doDirectiveCommentComplete: (uri: string, position: _.Position) => _.CompletionItem[] | undefined;
    doJsDocComplete: (uri: string, position: _.Position) => _.CompletionItem | undefined;
    doHover: (uri: string, position: _.Position, documentOnly?: boolean) => _.Hover | undefined;
    doFormatting: {
        onRange: (uri: string, options: _.FormattingOptions, range?: _.Range | undefined) => Promise<_.TextEdit[]>;
        onType: (uri: string, options: _.FormattingOptions, position: _.Position, key: string) => Promise<_.TextEdit[]>;
    };
    getSignatureHelp: (uri: string, position: _.Position, context?: _.SignatureHelpContext | undefined) => _.SignatureHelp | undefined;
    getSelectionRanges: (uri: string, positions: _.Position[]) => _.SelectionRange[];
    doValidation: (uri: string, options: {
        semantic?: boolean | undefined;
        syntactic?: boolean | undefined;
        suggestion?: boolean | undefined;
        declaration?: boolean | undefined;
    }, cancellationToken?: ts.CancellationToken | undefined) => _.Diagnostic[];
    getFoldingRanges: (uri: string) => _.FoldingRange[];
    getDocumentSemanticTokens: (uri: string, range?: _.Range | undefined, cancle?: _.CancellationToken | undefined) => [number, number, number, number, number][] | undefined;
    callHierarchy: {
        doPrepare: (uri: string, position: _.Position) => _.CallHierarchyItem[];
        getIncomingCalls: (item: _.CallHierarchyItem) => _.CallHierarchyIncomingCall[];
        getOutgoingCalls: (item: _.CallHierarchyItem) => _.CallHierarchyOutgoingCall[];
    };
    dispose: () => void;
    __internal__: {
        host: ts.LanguageServiceHost;
        raw: ts.LanguageService;
        getTextDocument: (uri: string) => TextDocument | undefined;
        getValidTextDocument: (uri: string) => TextDocument | undefined;
        isValidFile: (fileName: string) => boolean;
    };
};
