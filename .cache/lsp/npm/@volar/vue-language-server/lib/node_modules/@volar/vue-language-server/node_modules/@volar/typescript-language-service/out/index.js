var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createLanguageService = exports.getSemanticTokenLegend = void 0;
const completions = require("./services/completions/basic");
const directiveCommentCompletions = require("./services/completions/directiveComment");
const jsDocCompletions = require("./services/completions/jsDoc");
const completionResolve = require("./services/completions/resolve");
const definitions = require("./services/definition");
const typeDefinitions = require("./services/typeDefinition");
const references = require("./services/references");
const fileReferences = require("./services/fileReferences");
const prepareRename = require("./services/prepareRename");
const rename = require("./services/rename");
const fileRename = require("./services/fileRename");
const codeActions = require("./services/codeAction");
const codeActionResolve = require("./services/codeActionResolve");
const hover = require("./services/hover");
const signatureHelp = require("./services/signatureHelp");
const selectionRanges = require("./services/selectionRanges");
const diagnostics = require("./services/diagnostics");
const documentHighlight = require("./services/documentHighlight");
const documentSymbol = require("./services/documentSymbol");
const workspaceSymbols = require("./services/workspaceSymbol");
const formatting = require("./services/formatting");
const semanticTokens = require("./services/semanticTokens");
const foldingRanges = require("./services/foldingRanges");
const callHierarchy = require("./services/callHierarchy");
const implementation = require("./services/implementation");
const inlayHints = require("./services/inlayHints");
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const shared = require("@volar/shared");
var semanticTokens_1 = require("./services/semanticTokens");
Object.defineProperty(exports, "getSemanticTokenLegend", { enumerable: true, get: function () { return semanticTokens_1.getSemanticTokenLegend; } });
__exportStar(require("./configs/getFormatCodeSettings"), exports);
__exportStar(require("./configs/getUserPreferences"), exports);
;
function createLanguageService(ts, host, languageService, getConfiguration, rootUri) {
    const documents = shared.createUriMap();
    return {
        findDefinition: definitions.register(rootUri, languageService, getValidTextDocument, getTextDocument),
        findTypeDefinition: typeDefinitions.register(rootUri, languageService, getValidTextDocument, getTextDocument),
        findReferences: references.register(rootUri, languageService, getValidTextDocument, getTextDocument),
        findFileReferences: fileReferences.register(rootUri, languageService, getValidTextDocument, getTextDocument),
        findImplementations: implementation.register(rootUri, languageService, getValidTextDocument, getTextDocument),
        prepareRename: prepareRename.register(languageService, getValidTextDocument),
        doRename: rename.register(rootUri, languageService, getValidTextDocument, getConfiguration),
        getEditsForFileRename: fileRename.register(rootUri, languageService, getValidTextDocument, getConfiguration),
        getCodeActions: codeActions.register(rootUri, languageService, getValidTextDocument, getConfiguration),
        doCodeActionResolve: codeActionResolve.register(rootUri, languageService, getValidTextDocument, getConfiguration),
        getInlayHints: inlayHints.register(languageService, getValidTextDocument, getConfiguration, ts),
        findDocumentHighlights: documentHighlight.register(languageService, getValidTextDocument, ts),
        findDocumentSymbols: documentSymbol.register(languageService, getValidTextDocument),
        findWorkspaceSymbols: workspaceSymbols.register(rootUri, languageService, getTextDocument),
        doComplete: completions.register(languageService, getValidTextDocument, getConfiguration, ts),
        doCompletionResolve: completionResolve.register(rootUri, languageService, getValidTextDocument, getTextDocument, getConfiguration),
        doDirectiveCommentComplete: directiveCommentCompletions.register(getValidTextDocument),
        doJsDocComplete: jsDocCompletions.register(languageService, getValidTextDocument),
        doHover: hover.register(rootUri, languageService, getValidTextDocument, getTextDocument, ts),
        doFormatting: formatting.register(languageService, getValidTextDocument, getConfiguration),
        getSignatureHelp: signatureHelp.register(languageService, getValidTextDocument, ts),
        getSelectionRanges: selectionRanges.register(languageService, getValidTextDocument),
        doValidation: diagnostics.register(rootUri, languageService, getValidTextDocument, ts),
        getFoldingRanges: foldingRanges.register(languageService, getValidTextDocument, ts),
        getDocumentSemanticTokens: semanticTokens.register(languageService, getValidTextDocument, ts),
        callHierarchy: callHierarchy.register(rootUri, languageService, getValidTextDocument),
        dispose,
        __internal__: {
            host,
            raw: languageService,
            getTextDocument,
            getValidTextDocument,
            isValidFile,
        },
    };
    function getValidTextDocument(uri) {
        const fileName = shared.getPathOfUri(uri);
        if (!isValidFile(fileName)) {
            return;
        }
        return getTextDocument(uri);
    }
    function isValidFile(fileName) {
        var _a;
        if (!((_a = languageService.getProgram()) === null || _a === void 0 ? void 0 : _a.getSourceFile(fileName))) {
            return false;
        }
        return true;
    }
    function getTextDocument(uri) {
        var _a;
        const fileName = shared.getPathOfUri(uri);
        const version = host.getScriptVersion(fileName);
        const oldDoc = documents.uriGet(uri);
        if (!oldDoc || oldDoc[0] !== version) {
            const scriptSnapshot = host.getScriptSnapshot(fileName);
            if (scriptSnapshot) {
                const scriptText = scriptSnapshot.getText(0, scriptSnapshot.getLength());
                const document = vscode_languageserver_textdocument_1.TextDocument.create(uri, shared.syntaxToLanguageId(uri.substring(uri.lastIndexOf('.') + 1)), oldDoc ? oldDoc[1].version + 1 : 0, scriptText);
                documents.uriSet(uri, [version, document]);
            }
        }
        return (_a = documents.uriGet(uri)) === null || _a === void 0 ? void 0 : _a[1];
    }
    function dispose() {
        languageService.dispose();
    }
}
exports.createLanguageService = createLanguageService;
//# sourceMappingURL=index.js.map