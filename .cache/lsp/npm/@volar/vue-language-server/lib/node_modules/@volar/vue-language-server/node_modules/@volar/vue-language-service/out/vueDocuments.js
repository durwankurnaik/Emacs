var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseVueDocument = exports.parseVueDocuments = exports.TeleportSourceMap = exports.EmbeddedDocumentSourceMap = exports.SourceMap = void 0;
const vue = require("@volar/vue-language-core");
const shared = require("@volar/shared");
const reactivity_1 = require("@vue/reactivity");
const source_map_1 = require("@volar/source-map");
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const vue_language_core_1 = require("@volar/vue-language-core");
const vscode = require("vscode-languageserver-protocol");
class SourceMap {
    constructor(sourceDocument, mappedDocument, base = new source_map_1.SourceMapBase()) {
        this.sourceDocument = sourceDocument;
        this.mappedDocument = mappedDocument;
        this.base = base;
    }
    getSourceRange(start, end, filter) {
        for (const mapped of this.getRanges(start, end !== null && end !== void 0 ? end : start, false, filter)) {
            return mapped;
        }
    }
    getMappedRange(start, end, filter) {
        for (const mapped of this.getRanges(start, end !== null && end !== void 0 ? end : start, true, filter)) {
            return mapped;
        }
    }
    getSourceRanges(start, end, filter) {
        return this.getRanges(start, end !== null && end !== void 0 ? end : start, false, filter);
    }
    getMappedRanges(start, end, filter) {
        return this.getRanges(start, end !== null && end !== void 0 ? end : start, true, filter);
    }
    *getRanges(start, end, sourceToTarget, filter) {
        const startIsNumber = typeof start === 'number';
        const endIsNumber = typeof end === 'number';
        const toDoc = sourceToTarget ? this.mappedDocument : this.sourceDocument;
        const fromDoc = sourceToTarget ? this.sourceDocument : this.mappedDocument;
        const startOffset = startIsNumber ? start : fromDoc.offsetAt(start);
        const endOffset = endIsNumber ? end : fromDoc.offsetAt(end);
        for (const mapped of this.base.getRanges(startOffset, endOffset, sourceToTarget, filter)) {
            yield getMapped(mapped);
        }
        function getMapped(mapped) {
            if (startIsNumber) {
                return mapped;
            }
            return [{
                    start: toDoc.positionAt(mapped[0].start),
                    end: toDoc.positionAt(mapped[0].end),
                }, mapped[1]];
        }
    }
}
exports.SourceMap = SourceMap;
class EmbeddedDocumentSourceMap extends SourceMap {
    constructor(embeddedFile, sourceDocument, mappedDocument, _sourceMap) {
        super(sourceDocument, mappedDocument, _sourceMap);
        this.embeddedFile = embeddedFile;
        this.sourceDocument = sourceDocument;
        this.mappedDocument = mappedDocument;
    }
}
exports.EmbeddedDocumentSourceMap = EmbeddedDocumentSourceMap;
class TeleportSourceMap extends SourceMap {
    constructor(embeddedFile, document, teleport) {
        super(document, document, teleport);
        this.embeddedFile = embeddedFile;
        this.document = document;
    }
    *findTeleports(start, end, filter) {
        for (const [teleRange, data] of this.getMappedRanges(start, end, filter ? data => filter(data.toTarget) : undefined)) {
            yield [teleRange, data.toTarget];
        }
        for (const [teleRange, data] of this.getSourceRanges(start, end, filter ? data => filter(data.toSource) : undefined)) {
            yield [teleRange, data.toSource];
        }
    }
}
exports.TeleportSourceMap = TeleportSourceMap;
function parseVueDocuments(rootUri, vueLsCtx, tsLs) {
    const _vueDocuments = new WeakMap();
    // reactivity
    const embeddedDocumentsMap = (0, reactivity_1.computed)(() => {
        const map = new Map();
        for (const vueDocument of getAll()) {
            for (const sourceMap of vueDocument.getSourceMaps()) {
                map.set(sourceMap.mappedDocument, vueDocument);
            }
        }
        return map;
    });
    const embeddedDocumentsMapLsType = (0, reactivity_1.computed)(() => {
        const map = new Map();
        for (const vueDocument of getAll()) {
            for (const sourceMap of vueDocument.getSourceMaps()) {
                map.set(sourceMap.mappedDocument.uri, sourceMap);
            }
        }
        return map;
    });
    const teleportsMapLsType = (0, reactivity_1.computed)(() => {
        const map = new Map();
        for (const vueDocument of getAll()) {
            for (const teleport of vueDocument.getTeleports()) {
                map.set(teleport.mappedDocument.uri, teleport);
            }
        }
        return map;
    });
    return {
        getAll: getAll,
        get: (uri) => {
            const fileName = shared.getPathOfUri(uri);
            const vueFile = vueLsCtx.mapper.get(fileName);
            if (vueFile) {
                return get(vueFile);
            }
        },
        fromEmbeddedDocument: (document) => {
            return embeddedDocumentsMap.value.get(document);
        },
        sourceMapFromEmbeddedDocumentUri: (uri) => {
            return embeddedDocumentsMapLsType.value.get(uri);
        },
        teleportfromEmbeddedDocumentUri: (uri) => {
            return teleportsMapLsType.value.get(uri);
        },
        fromEmbeddedLocation: function* (uri, start, end, filter, sourceMapFilter) {
            if (uri.endsWith(`/${vue.localTypes.typesFileName}`))
                return;
            if (end === undefined)
                end = start;
            const sourceMap = embeddedDocumentsMapLsType.value.get(uri);
            if (sourceMap) {
                if (sourceMapFilter && !sourceMapFilter(sourceMap.base))
                    return;
                for (const vueRange of sourceMap.getSourceRanges(start, end, filter)) {
                    yield {
                        uri: sourceMap.sourceDocument.uri,
                        range: vueRange[0],
                        sourceMap,
                        data: vueRange[1],
                    };
                }
            }
            else {
                yield {
                    uri,
                    range: {
                        start,
                        end,
                    },
                };
            }
        },
    };
    function get(vueFile) {
        let vueDocument = _vueDocuments.get(vueFile);
        if (!vueDocument) {
            vueDocument = parseVueDocument(rootUri, vueFile, tsLs);
            _vueDocuments.set(vueFile, vueDocument);
        }
        return vueDocument;
    }
    function getAll() {
        return vueLsCtx.mapper.getAll().map(get);
    }
}
exports.parseVueDocuments = parseVueDocuments;
function parseVueDocument(rootUri, vueFile, tsLs) {
    let documentVersion = 0;
    let templateScriptData = {
        components: [],
        componentItems: [],
    };
    const embeddedDocumentVersions = new Map();
    const embeddedDocuments = new WeakMap();
    const sourceMaps = new WeakMap();
    // computed
    const document = (0, reactivity_1.computed)(() => vscode_languageserver_textdocument_1.TextDocument.create(shared.getUriByPath(rootUri, vueFile.fileName), vueFile.fileName.endsWith('.md') ? 'markdown' : 'vue', documentVersion++, vueFile.text));
    const allSourceMaps = (0, reactivity_1.computed)(() => {
        return vueFile.allEmbeddeds.map(getSourceMap);
    });
    const teleports = (0, reactivity_1.computed)(() => {
        return vueFile.teleports.map(teleportAndFile => {
            const embeddedDocument = getEmbeddedDocument(teleportAndFile.file);
            const sourceMap = new TeleportSourceMap(teleportAndFile.file, embeddedDocument, teleportAndFile.teleport);
            return sourceMap;
        });
    });
    const templateTagsAndAttrs = (0, reactivity_1.computed)(() => {
        var _a;
        const ast = (_a = vueFile.compiledSFCTemplate) === null || _a === void 0 ? void 0 : _a.ast;
        const tags = new Map();
        const attrs = new Set();
        if (ast) {
            (0, vue_language_core_1.walkElementNodes)(ast, node => {
                var _a;
                if (!tags.has(node.tag)) {
                    tags.set(node.tag, []);
                }
                const offsets = tags.get(node.tag);
                const startTagHtmlOffset = node.loc.start.offset + node.loc.source.indexOf(node.tag);
                const endTagHtmlOffset = node.loc.start.offset + node.loc.source.lastIndexOf(node.tag);
                offsets.push(startTagHtmlOffset);
                offsets.push(endTagHtmlOffset);
                for (const prop of node.props) {
                    if (prop.type === 7 /* CompilerDOM.NodeTypes.DIRECTIVE */
                        && ((_a = prop.arg) === null || _a === void 0 ? void 0 : _a.type) === 4 /* CompilerDOM.NodeTypes.SIMPLE_EXPRESSION */
                        && prop.arg.isStatic) {
                        attrs.add(prop.arg.content);
                    }
                    else if (prop.type === 6 /* CompilerDOM.NodeTypes.ATTRIBUTE */) {
                        attrs.add(prop.name);
                    }
                }
            });
        }
        return {
            tags,
            attrs,
        };
    });
    return {
        uri: shared.getUriByPath(rootUri, vueFile.fileName),
        file: vueFile,
        getSourceMap,
        getEmbeddedDocument,
        getTemplateData,
        getSourceMaps: () => allSourceMaps.value,
        getTeleports: () => teleports.value,
        getDocument: () => document.value,
        getTemplateTagsAndAttrs: () => templateTagsAndAttrs.value,
    };
    function getSourceMap(embedded) {
        let cache = sourceMaps.get(embedded);
        if (!cache || cache[0] !== document.value.version) {
            cache = [
                document.value.version,
                new EmbeddedDocumentSourceMap(embedded.file, document.value, getEmbeddedDocument(embedded.file), embedded.sourceMap)
            ];
            sourceMaps.set(embedded, cache);
        }
        return cache[1];
    }
    function getEmbeddedDocument(embeddedFile) {
        var _a;
        let document = embeddedDocuments.get(embeddedFile);
        if (!document) {
            const uri = shared.getUriByPath(rootUri, embeddedFile.fileName);
            const newVersion = ((_a = embeddedDocumentVersions.get(uri.toLowerCase())) !== null && _a !== void 0 ? _a : 0) + 1;
            embeddedDocumentVersions.set(uri.toLowerCase(), newVersion);
            document = vscode_languageserver_textdocument_1.TextDocument.create(uri, shared.syntaxToLanguageId(embeddedFile.fileName.split('.').pop()), newVersion, embeddedFile.codeGen.getText());
            embeddedDocuments.set(embeddedFile, document);
        }
        return document;
    }
    function getTemplateData() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const options = {
                includeCompletionsWithInsertText: true, // if missing, { 'aaa-bbb': any, ccc: any } type only has result ['ccc']
            };
            const file = (_a = vueFile.allEmbeddeds.find(e => e.file.fileName === vueFile.tsFileName)) === null || _a === void 0 ? void 0 : _a.file;
            if (file && file.codeGen.getText().indexOf(vue.SearchTexts.Components) >= 0) {
                const document = getEmbeddedDocument(file);
                let components = yield (tsLs === null || tsLs === void 0 ? void 0 : tsLs.doComplete(shared.getUriByPath(rootUri, file.fileName), document.positionAt(file.codeGen.getText().indexOf(vue.SearchTexts.Components)), options));
                if (components) {
                    const items = components.items
                        .filter(entry => entry.kind !== vscode.CompletionItemKind.Text)
                        .filter(entry => entry.label.indexOf('$') === -1 && !entry.label.startsWith('_'));
                    const componentNames = items.map(entry => entry.label);
                    templateScriptData = {
                        components: componentNames,
                        componentItems: items,
                    };
                }
            }
            return templateScriptData;
        });
    }
}
exports.parseVueDocument = parseVueDocument;
//# sourceMappingURL=vueDocuments.js.map