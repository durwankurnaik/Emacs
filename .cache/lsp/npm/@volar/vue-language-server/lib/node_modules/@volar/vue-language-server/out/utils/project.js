var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createProject = void 0;
const shared = require("@volar/shared");
const vue = require("@volar/vue-language-service");
const vscode = require("vscode-languageserver");
const config_1 = require("./config");
const requests_1 = require("../requests");
function createProject(runtimeEnv, languageConfigs, fsHost, sys, ts, options, rootUri, rootPath, tsConfig, tsLocalized, documents, connection, configHost) {
    return __awaiter(this, void 0, void 0, function* () {
        let typeRootVersion = 0;
        let projectVersion = 0;
        let vueLs;
        let parsedCommandLine;
        try {
            // will be failed if web fs host first result not ready
            parsedCommandLine = createParsedCommandLine();
        }
        catch (_a) {
            parsedCommandLine = {
                errors: [],
                fileNames: [],
                options: {},
                vueOptions: {},
            };
        }
        const scripts = shared.createUriMap();
        const languageServiceHost = createLanguageServiceHost();
        const disposeWatchEvent = fsHost.onDidChangeWatchedFiles(params => {
            onWorkspaceFilesChanged(params.changes);
        });
        const disposeDocChange = documents.onDidChangeContent(params => {
            projectVersion++;
        });
        return {
            getLanguageService,
            getLanguageServiceDontCreate: () => vueLs,
            getParsedCommandLine: () => parsedCommandLine,
            dispose,
        };
        function getLanguageService() {
            var _a;
            if (!vueLs) {
                vueLs = languageConfigs.createLanguageService(languageServiceHost, runtimeEnv.fileSystemProvide, (uri) => {
                    var _a;
                    const protocol = uri.substring(0, uri.indexOf(':'));
                    const builtInHandler = runtimeEnv.schemaRequestHandlers[protocol];
                    if (builtInHandler) {
                        return builtInHandler(uri);
                    }
                    if (typeof options === 'object' && ((_a = options.languageFeatures) === null || _a === void 0 ? void 0 : _a.schemaRequestService)) {
                        return connection.sendRequest(requests_1.GetDocumentContentRequest.type, { uri }).then(responseText => {
                            return responseText;
                        }, error => {
                            return Promise.reject(error.message);
                        });
                    }
                    else {
                        return Promise.reject('clientHandledGetDocumentContentRequest is false');
                    }
                }, configHost, (0, config_1.loadCustomPlugins)(languageServiceHost.getCurrentDirectory()), ((_a = options.languageFeatures) === null || _a === void 0 ? void 0 : _a.completion) ? (uri) => __awaiter(this, void 0, void 0, function* () {
                    var _b, _c;
                    if ((_c = (_b = options.languageFeatures) === null || _b === void 0 ? void 0 : _b.completion) === null || _c === void 0 ? void 0 : _c.getDocumentNameCasesRequest) {
                        const res = yield connection.sendRequest(requests_1.GetDocumentNameCasesRequest.type, { uri });
                        return {
                            tag: res.tagNameCase,
                            attr: res.attrNameCase,
                        };
                    }
                    return {
                        tag: options.languageFeatures.completion.defaultTagNameCase,
                        attr: options.languageFeatures.completion.defaultAttrNameCase,
                    };
                }) : undefined, undefined, rootUri);
            }
            return vueLs;
        }
        function onWorkspaceFilesChanged(changes) {
            return __awaiter(this, void 0, void 0, function* () {
                for (const change of changes) {
                    const script = scripts.uriGet(change.uri);
                    if (script && (change.type === vscode.FileChangeType.Changed || change.type === vscode.FileChangeType.Created)) {
                        if (script.version >= 0) {
                            script.version = -1;
                        }
                        else {
                            script.version--;
                        }
                    }
                    else if (script && change.type === vscode.FileChangeType.Deleted) {
                        scripts.uriDelete(change.uri);
                    }
                    if (script) {
                        projectVersion++;
                        typeRootVersion++;
                    }
                }
                const creates = changes.filter(change => change.type === vscode.FileChangeType.Created);
                const deletes = changes.filter(change => change.type === vscode.FileChangeType.Deleted);
                if (creates.length || deletes.length) {
                    parsedCommandLine = createParsedCommandLine();
                }
            });
        }
        function createLanguageServiceHost() {
            const host = {
                // ts
                getNewLine: () => sys.newLine,
                useCaseSensitiveFileNames: () => sys.useCaseSensitiveFileNames,
                readFile: sys.readFile,
                writeFile: sys.writeFile,
                directoryExists: sys.directoryExists,
                getDirectories: sys.getDirectories,
                readDirectory: sys.readDirectory,
                realpath: sys.realpath,
                fileExists: sys.fileExists,
                getCurrentDirectory: () => rootPath,
                getProjectReferences: () => parsedCommandLine.projectReferences,
                // custom
                getDefaultLibFileName: options => {
                    try {
                        return ts.getDefaultLibFilePath(options);
                    }
                    catch (_a) {
                        return sys.resolvePath('node_modules/typescript/lib/' + ts.getDefaultLibFileName(options)); // web
                    }
                },
                getProjectVersion: () => projectVersion.toString(),
                getTypeRootsVersion: () => typeRootVersion,
                getScriptFileNames: () => {
                    const fileNames = new Set(parsedCommandLine.fileNames);
                    for (const script of scripts.values()) {
                        fileNames.add(script.fileName);
                    }
                    return [...fileNames];
                },
                getCompilationSettings: () => parsedCommandLine.options,
                getVueCompilationSettings: () => parsedCommandLine.vueOptions,
                getScriptVersion,
                getScriptSnapshot,
                getTypeScriptModule: () => ts,
            };
            if (tsLocalized) {
                host.getLocalizedDiagnosticMessages = () => tsLocalized;
            }
            return host;
            function getScriptVersion(fileName) {
                var _a, _b;
                const doc = documents.data.pathGet(rootUri, fileName);
                if (doc) {
                    return doc.version.toString();
                }
                return (_b = (_a = scripts.pathGet(rootUri, fileName)) === null || _a === void 0 ? void 0 : _a.version.toString()) !== null && _b !== void 0 ? _b : '';
            }
            function getScriptSnapshot(fileName) {
                const doc = documents.data.pathGet(rootUri, fileName);
                if (doc) {
                    return doc.getSnapshot();
                }
                const script = scripts.pathGet(rootUri, fileName);
                if (script && script.snapshotVersion === script.version) {
                    return script.snapshot;
                }
                if (sys.fileExists(fileName)) {
                    const text = sys.readFile(fileName, 'utf8');
                    if (text !== undefined) {
                        const snapshot = ts.ScriptSnapshot.fromString(text);
                        if (script) {
                            script.snapshot = snapshot;
                            script.snapshotVersion = script.version;
                        }
                        else {
                            scripts.pathSet(rootUri, fileName, {
                                version: -1,
                                fileName: fileName,
                                snapshot: snapshot,
                                snapshotVersion: -1,
                            });
                        }
                        return snapshot;
                    }
                }
            }
        }
        function dispose() {
            vueLs === null || vueLs === void 0 ? void 0 : vueLs.dispose();
            scripts.clear();
            disposeWatchEvent();
            disposeDocChange();
        }
        function createParsedCommandLine() {
            const parseConfigHost = {
                useCaseSensitiveFileNames: sys.useCaseSensitiveFileNames,
                readDirectory: (path, extensions, exclude, include, depth) => {
                    const exts = [...extensions, ...languageConfigs.definitelyExts];
                    for (const passiveExt of languageConfigs.indeterminateExts) {
                        if (include.some(i => i.endsWith(passiveExt))) {
                            exts.push(passiveExt);
                        }
                    }
                    return sys.readDirectory(path, exts, exclude, include, depth);
                },
                fileExists: sys.fileExists,
                readFile: sys.readFile,
            };
            if (typeof tsConfig === 'string') {
                return vue.createParsedCommandLine(ts, parseConfigHost, tsConfig);
            }
            else {
                const content = ts.parseJsonConfigFileContent({}, parseConfigHost, rootPath, tsConfig, 'jsconfig.json');
                content.options.outDir = undefined; // TODO: patching ts server broke with outDir + rootDir + composite/incremental
                content.fileNames = content.fileNames.map(shared.normalizeFileName);
                return Object.assign(Object.assign({}, content), { vueOptions: {} });
            }
        }
    });
}
exports.createProject = createProject;
//# sourceMappingURL=project.js.map