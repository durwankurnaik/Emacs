var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fileTextChangesToWorkspaceEdit = exports.register = void 0;
const vscode = require("vscode-languageserver-protocol");
const shared = require("@volar/shared");
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const path = require("upath");
const prepareRename_1 = require("./prepareRename");
const getFormatCodeSettings_1 = require("../configs/getFormatCodeSettings");
const getUserPreferences_1 = require("../configs/getUserPreferences");
function register(rootUri, languageService, getTextDocument, getConfiguration) {
    return (uri, position, newName) => __awaiter(this, void 0, void 0, function* () {
        const document = getTextDocument(uri);
        if (!document)
            return;
        const fileName = shared.getPathOfUri(document.uri);
        const offset = document.offsetAt(position);
        let renameInfo;
        try {
            renameInfo = languageService.getRenameInfo(fileName, offset, prepareRename_1.renameInfoOptions);
        }
        catch (_a) { }
        if (!(renameInfo === null || renameInfo === void 0 ? void 0 : renameInfo.canRename))
            return;
        if (renameInfo.fileToRename) {
            const [formatOptions, preferences] = yield Promise.all([
                (0, getFormatCodeSettings_1.getFormatCodeSettings)(getConfiguration, document.uri),
                (0, getUserPreferences_1.getUserPreferences)(getConfiguration, document.uri),
            ]);
            return renameFile(renameInfo.fileToRename, newName, formatOptions, preferences);
        }
        const { providePrefixAndSuffixTextForRename } = yield (0, getUserPreferences_1.getUserPreferences)(getConfiguration, document.uri);
        const entries = languageService.findRenameLocations(fileName, offset, false, false, providePrefixAndSuffixTextForRename);
        if (!entries)
            return;
        const locations = locationsToWorkspaceEdit(rootUri, newName, entries, getTextDocument);
        return locations;
    });
    function renameFile(fileToRename, newName, formatOptions, preferences) {
        // Make sure we preserve file extension if none provided
        if (!path.extname(newName)) {
            newName += path.extname(fileToRename);
        }
        const dirname = path.dirname(fileToRename);
        const newFilePath = path.join(dirname, newName);
        const response = languageService.getEditsForFileRename(fileToRename, newFilePath, formatOptions, preferences);
        const edits = fileTextChangesToWorkspaceEdit(rootUri, response, getTextDocument);
        if (!edits.documentChanges) {
            edits.documentChanges = [];
        }
        edits.documentChanges.push(vscode.RenameFile.create(shared.getUriByPath(rootUri, fileToRename), shared.getUriByPath(rootUri, newFilePath)));
        return edits;
    }
}
exports.register = register;
function fileTextChangesToWorkspaceEdit(rootUri, changes, getTextDocument) {
    const workspaceEdit = {};
    for (const change of changes) {
        if (!workspaceEdit.documentChanges) {
            workspaceEdit.documentChanges = [];
        }
        const uri = shared.getUriByPath(rootUri, change.fileName);
        let doc = getTextDocument(uri);
        if (change.isNewFile) {
            workspaceEdit.documentChanges.push(vscode.CreateFile.create(uri));
            doc = vscode_languageserver_textdocument_1.TextDocument.create(uri, 'typescript', 0, '');
        }
        if (!doc)
            continue;
        const docEdit = vscode.TextDocumentEdit.create({ uri: uri, version: doc.version }, []);
        for (const textChange of change.textChanges) {
            docEdit.edits.push({
                newText: textChange.newText,
                range: {
                    start: doc.positionAt(textChange.span.start),
                    end: doc.positionAt(textChange.span.start + textChange.span.length),
                },
            });
        }
        workspaceEdit.documentChanges.push(docEdit);
    }
    return workspaceEdit;
}
exports.fileTextChangesToWorkspaceEdit = fileTextChangesToWorkspaceEdit;
function locationsToWorkspaceEdit(rootUri, newText, locations, getTextDocument) {
    const workspaceEdit = {};
    for (const location of locations) {
        if (!workspaceEdit.changes) {
            workspaceEdit.changes = {};
        }
        const uri = shared.getUriByPath(rootUri, location.fileName);
        const doc = getTextDocument(uri);
        if (!doc)
            continue;
        if (!workspaceEdit.changes[uri]) {
            workspaceEdit.changes[uri] = [];
        }
        let _newText = newText;
        if (location.prefixText)
            _newText = location.prefixText + _newText;
        if (location.suffixText)
            _newText = _newText + location.suffixText;
        workspaceEdit.changes[uri].push({
            newText: _newText,
            range: {
                start: doc.positionAt(location.textSpan.start),
                end: doc.positionAt(location.textSpan.start + location.textSpan.length),
            },
        });
    }
    return workspaceEdit;
}
//# sourceMappingURL=rename.js.map