var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.semanticTokenTypes = void 0;
const shared = require("@volar/shared");
const ts2 = require("@volar/typescript-language-service");
const vue_language_core_1 = require("@volar/vue-language-core");
const vue_language_core_2 = require("@volar/vue-language-core");
const vue = require("@volar/vue-language-core");
const vue_language_service_types_1 = require("@volar/vue-language-service-types");
const shared_1 = require("@vue/shared");
const path = require("upath");
const html = require("vscode-html-languageservice");
const vscode = require("vscode-languageserver-protocol");
exports.semanticTokenTypes = [
    'componentTag',
];
// https://v3.vuejs.org/api/directives.html#v-on
const eventModifiers = {
    stop: 'call event.stopPropagation().',
    prevent: 'call event.preventDefault().',
    capture: 'add event listener in capture mode.',
    self: 'only trigger handler if event was dispatched from this element.',
    // {keyAlias}: 'only trigger handler on certain keys.',
    once: 'trigger handler at most once.',
    left: 'only trigger handler for left button mouse events.',
    right: 'only trigger handler for right button mouse events.',
    middle: 'only trigger handler for middle button mouse events.',
    passive: 'attaches a DOM event with { passive: true }.',
};
const vueGlobalDirectiveProvider = html.newHTMLDataProvider('vueGlobalDirective', {
    version: 1.1,
    tags: [],
    globalAttributes: [
        { name: 'v-if' },
        { name: 'v-else-if' },
        { name: 'v-else', valueSet: 'v' },
        { name: 'v-for' },
    ],
});
function useVueTemplateLanguagePlugin(options) {
    var _a, _b;
    const componentCompletionDataCache = new WeakMap();
    const autoImportPositions = new WeakSet();
    const tokenTypes = new Map(options.getSemanticTokenLegend().tokenTypes.map((t, i) => [t, i]));
    const runtimeMode = (0, vue_language_core_1.getVueCompilerOptions)(options.vueLsHost.getVueCompilationSettings()).experimentalRuntimeMode;
    return Object.assign(Object.assign({}, options.templateLanguagePlugin), { complete: {
            triggerCharacters: [
                ...(_b = (_a = options.templateLanguagePlugin.complete) === null || _a === void 0 ? void 0 : _a.triggerCharacters) !== null && _b !== void 0 ? _b : [],
                '@', // vue event shorthand
            ],
            on(document, position, context) {
                var _a, _b;
                return __awaiter(this, void 0, void 0, function* () {
                    if (!options.isSupportedDocument(document))
                        return;
                    const vueDocument = options.vueDocuments.fromEmbeddedDocument(document);
                    let tsItems;
                    if (vueDocument) {
                        tsItems = yield provideHtmlData(vueDocument);
                    }
                    const htmlComplete = yield ((_b = (_a = options.templateLanguagePlugin.complete) === null || _a === void 0 ? void 0 : _a.on) === null || _b === void 0 ? void 0 : _b.call(_a, document, position, context));
                    if (!htmlComplete)
                        return;
                    if (vueDocument && tsItems) {
                        afterHtmlCompletion(htmlComplete, vueDocument, tsItems);
                    }
                    return htmlComplete;
                });
            },
            resolve(item) {
                return __awaiter(this, void 0, void 0, function* () {
                    const data = item.data;
                    if ((data === null || data === void 0 ? void 0 : data.mode) === 'html') {
                        return yield resolveHtmlItem(item, data);
                    }
                    else if ((data === null || data === void 0 ? void 0 : data.mode) === 'autoImport') {
                        return yield resolveAutoImportItem(item, data);
                    }
                    return item;
                });
            },
        }, doHover(document, position) {
            var _a, _b;
            if (!options.isSupportedDocument(document))
                return;
            const vueDocument = options.vueDocuments.fromEmbeddedDocument(document);
            if (vueDocument) {
                options.templateLanguagePlugin.updateCustomData([]);
            }
            return (_b = (_a = options.templateLanguagePlugin).doHover) === null || _b === void 0 ? void 0 : _b.call(_a, document, position);
        },
        doValidation(document, options_2) {
            var _a, _b;
            return __awaiter(this, void 0, void 0, function* () {
                if (!options.isSupportedDocument(document))
                    return;
                const originalResult = yield ((_b = (_a = options.templateLanguagePlugin).doValidation) === null || _b === void 0 ? void 0 : _b.call(_a, document, options_2));
                const vueDocument = options.vueDocuments.fromEmbeddedDocument(document);
                if (vueDocument) {
                    const templateErrors = [];
                    const sfcVueTemplateCompiled = vueDocument.file.compiledSFCTemplate;
                    if (sfcVueTemplateCompiled) {
                        for (const error of sfcVueTemplateCompiled.errors) {
                            onCompilerError(error, vscode.DiagnosticSeverity.Error);
                        }
                        for (const warning of sfcVueTemplateCompiled.warnings) {
                            onCompilerError(warning, vscode.DiagnosticSeverity.Warning);
                        }
                        function onCompilerError(error, severity) {
                            var _a, _b, _c, _d;
                            const templateHtmlRange = {
                                start: (_b = (_a = error.loc) === null || _a === void 0 ? void 0 : _a.start.offset) !== null && _b !== void 0 ? _b : 0,
                                end: (_d = (_c = error.loc) === null || _c === void 0 ? void 0 : _c.end.offset) !== null && _d !== void 0 ? _d : 0,
                            };
                            let errorMessage = error.message;
                            templateErrors.push({
                                range: {
                                    start: document.positionAt(templateHtmlRange.start),
                                    end: document.positionAt(templateHtmlRange.end),
                                },
                                severity,
                                code: error.code,
                                source: 'vue',
                                message: errorMessage,
                            });
                        }
                    }
                    return [
                        ...originalResult !== null && originalResult !== void 0 ? originalResult : [],
                        ...templateErrors,
                    ];
                }
            });
        },
        findDocumentSemanticTokens(document, range) {
            var _a, _b, _c, _d;
            return __awaiter(this, void 0, void 0, function* () {
                if (!options.isSupportedDocument(document))
                    return;
                const result = (_c = yield ((_b = (_a = options.templateLanguagePlugin).findDocumentSemanticTokens) === null || _b === void 0 ? void 0 : _b.call(_a, document, range))) !== null && _c !== void 0 ? _c : [];
                const vueDocument = options.vueDocuments.fromEmbeddedDocument(document);
                const scanner = options.getScanner(document);
                if (vueDocument && scanner) {
                    const templateScriptData = yield vueDocument.getTemplateData();
                    const components = new Set([
                        ...templateScriptData.components,
                        ...templateScriptData.components.map(shared_1.hyphenate).filter(name => !(0, vue_language_core_1.isIntrinsicElement)(runtimeMode, name)),
                    ]);
                    const offsetRange = range ? {
                        start: document.offsetAt(range.start),
                        end: document.offsetAt(range.end),
                    } : {
                        start: 0,
                        end: document.getText().length,
                    };
                    let token = scanner.scan();
                    while (token !== html.TokenType.EOS) {
                        const tokenOffset = scanner.getTokenOffset();
                        // TODO: fix source map perf and break in while condition
                        if (tokenOffset > offsetRange.end)
                            break;
                        if (tokenOffset >= offsetRange.start && (token === html.TokenType.StartTag || token === html.TokenType.EndTag)) {
                            const tokenText = scanner.getTokenText();
                            if (components.has(tokenText) || tokenText.indexOf('.') >= 0) {
                                const tokenLength = scanner.getTokenLength();
                                const tokenPosition = document.positionAt(tokenOffset);
                                if (components.has(tokenText)) {
                                    result.push([tokenPosition.line, tokenPosition.character, tokenLength, (_d = tokenTypes.get('componentTag')) !== null && _d !== void 0 ? _d : -1, 0]);
                                }
                            }
                        }
                        token = scanner.scan();
                    }
                }
                return result;
            });
        },
        resolveEmbeddedRange(range) {
            if (autoImportPositions.has(range.start) && autoImportPositions.has(range.end))
                return range;
        } });
    function resolveHtmlItem(item, data) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            let tsItem = data.tsItem;
            if (!tsItem)
                return item;
            tsItem = yield options.tsLs.doCompletionResolve(tsItem);
            item.tags = [...(_a = item.tags) !== null && _a !== void 0 ? _a : [], ...(_b = tsItem.tags) !== null && _b !== void 0 ? _b : []];
            const details = [];
            const documentations = [];
            if (item.detail)
                details.push(item.detail);
            if (tsItem.detail)
                details.push(tsItem.detail);
            if (details.length) {
                item.detail = details.join('\n\n');
            }
            if (item.documentation)
                documentations.push(typeof item.documentation === 'string' ? item.documentation : item.documentation.value);
            if (tsItem.documentation)
                documentations.push(typeof tsItem.documentation === 'string' ? tsItem.documentation : tsItem.documentation.value);
            if (documentations.length) {
                item.documentation = {
                    kind: vscode.MarkupKind.Markdown,
                    value: documentations.join('\n\n'),
                };
            }
            return item;
        });
    }
    function resolveAutoImportItem(item, data) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const _vueDocument = options.vueDocuments.get(data.vueDocumentUri);
            if (!_vueDocument)
                return item;
            const vueDocument = _vueDocument;
            const importFile = shared.getPathOfUri(data.importUri);
            const rPath = path.relative(options.vueLsHost.getCurrentDirectory(), importFile);
            const sfc = vueDocument.file.sfc;
            let importPath = path.relative(path.dirname(data.vueDocumentUri), data.importUri);
            if (!importPath.startsWith('.')) {
                importPath = './' + importPath;
            }
            if (!sfc.scriptSetup && !sfc.script) {
                item.detail = `Auto import from '${importPath}'\n\n${rPath}`;
                item.documentation = {
                    kind: vscode.MarkupKind.Markdown,
                    value: '[Error] `<script>` / `<script setup>` block not found.',
                };
                return item;
            }
            item.labelDetails = { description: rPath };
            const scriptImport = sfc.scriptAst ? getLastImportNode(sfc.scriptAst) : undefined;
            const scriptSetupImport = sfc.scriptSetupAst ? getLastImportNode(sfc.scriptSetupAst) : undefined;
            const componentName = (0, shared_1.capitalize)((0, shared_1.camelize)(item.label.replace(/\./g, '-')));
            const textDoc = vueDocument.getDocument();
            const insert = (_a = yield getTypeScriptInsert()) !== null && _a !== void 0 ? _a : getMonkeyInsert();
            if (insert.description) {
                item.detail = insert.description + '\n\n' + rPath;
            }
            if (sfc.scriptSetup) {
                const editPosition = textDoc.positionAt(sfc.scriptSetup.startTagEnd + (scriptSetupImport ? scriptSetupImport.end : 0));
                autoImportPositions.add(editPosition);
                item.additionalTextEdits = [
                    vscode.TextEdit.insert(editPosition, '\n' + insert.insertText),
                ];
            }
            else if (sfc.script && sfc.scriptAst) {
                const editPosition = textDoc.positionAt(sfc.script.startTagEnd + (scriptImport ? scriptImport.end : 0));
                autoImportPositions.add(editPosition);
                item.additionalTextEdits = [
                    vscode.TextEdit.insert(editPosition, '\n' + insert.insertText),
                ];
                const _scriptRanges = vue_language_core_2.scriptRanges.parseScriptRanges(options.ts, sfc.scriptAst, !!sfc.scriptSetup, true, true);
                const exportDefault = _scriptRanges.exportDefault;
                if (exportDefault) {
                    // https://github.com/microsoft/TypeScript/issues/36174
                    const printer = options.ts.createPrinter();
                    if (exportDefault.componentsOption && exportDefault.componentsOptionNode) {
                        const newNode = Object.assign(Object.assign({}, exportDefault.componentsOptionNode), { properties: [
                                ...exportDefault.componentsOptionNode.properties,
                                options.ts.factory.createShorthandPropertyAssignment(componentName),
                            ] });
                        const printText = printer.printNode(options.ts.EmitHint.Expression, newNode, sfc.scriptAst);
                        const editRange = vscode.Range.create(textDoc.positionAt(sfc.script.startTagEnd + exportDefault.componentsOption.start), textDoc.positionAt(sfc.script.startTagEnd + exportDefault.componentsOption.end));
                        autoImportPositions.add(editRange.start);
                        autoImportPositions.add(editRange.end);
                        item.additionalTextEdits.push(vscode.TextEdit.replace(editRange, unescape(printText.replace(/\\u/g, '%u'))));
                    }
                    else if (exportDefault.args && exportDefault.argsNode) {
                        const newNode = Object.assign(Object.assign({}, exportDefault.argsNode), { properties: [
                                ...exportDefault.argsNode.properties,
                                options.ts.factory.createShorthandPropertyAssignment(`components: { ${componentName} }`),
                            ] });
                        const printText = printer.printNode(options.ts.EmitHint.Expression, newNode, sfc.scriptAst);
                        const editRange = vscode.Range.create(textDoc.positionAt(sfc.script.startTagEnd + exportDefault.args.start), textDoc.positionAt(sfc.script.startTagEnd + exportDefault.args.end));
                        autoImportPositions.add(editRange.start);
                        autoImportPositions.add(editRange.end);
                        item.additionalTextEdits.push(vscode.TextEdit.replace(editRange, unescape(printText.replace(/\\u/g, '%u'))));
                    }
                }
            }
            return item;
            function getTypeScriptInsert() {
                return __awaiter(this, void 0, void 0, function* () {
                    const embeddedScriptUri = shared.getUriByPath(options.rootUri, vueDocument.file.tsFileName);
                    const tsImportName = (0, shared_1.camelize)(path.basename(importFile).replace(/\./g, '-'));
                    const confitHost = (0, vue_language_service_types_1.useConfigurationHost)();
                    const [formatOptions, preferences] = yield Promise.all([
                        ts2.getFormatCodeSettings((section, scopeUri) => confitHost === null || confitHost === void 0 ? void 0 : confitHost.getConfiguration(section, scopeUri), embeddedScriptUri),
                        ts2.getUserPreferences((section, scopeUri) => confitHost === null || confitHost === void 0 ? void 0 : confitHost.getConfiguration(section, scopeUri), embeddedScriptUri),
                    ]);
                    preferences.importModuleSpecifierEnding = 'minimal';
                    const tsDetail = options.tsLs.__internal__.raw.getCompletionEntryDetails(shared.getPathOfUri(embeddedScriptUri), 0, tsImportName, formatOptions, importFile, preferences, undefined);
                    if (tsDetail === null || tsDetail === void 0 ? void 0 : tsDetail.codeActions) {
                        for (const action of tsDetail.codeActions) {
                            for (const change of action.changes) {
                                for (const textChange of change.textChanges) {
                                    if (textChange.newText.indexOf(`import ${tsImportName} `) >= 0) {
                                        return {
                                            insertText: textChange.newText.replace(`import ${tsImportName} `, `import ${componentName} `).trim(),
                                            description: action.description,
                                        };
                                    }
                                }
                            }
                        }
                    }
                });
            }
            function getMonkeyInsert() {
                const anyImport = scriptSetupImport !== null && scriptSetupImport !== void 0 ? scriptSetupImport : scriptImport;
                let withSemicolon = true;
                let quote = '"';
                if (anyImport) {
                    withSemicolon = anyImport.text.endsWith(';');
                    quote = anyImport.text.includes("'") ? "'" : '"';
                }
                return {
                    insertText: `import ${componentName} from ${quote}${importPath}${quote}${withSemicolon ? ';' : ''}`,
                    description: '',
                };
            }
        });
    }
    function provideHtmlData(vueDocument) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            const nameCases = (_b = yield ((_a = options.getNameCases) === null || _a === void 0 ? void 0 : _a.call(options, vueDocument.uri))) !== null && _b !== void 0 ? _b : {
                tag: 'both',
                attr: 'kebabCase',
            };
            const componentCompletion = yield getComponentCompletionData(vueDocument);
            const tags = [];
            const tsItems = new Map();
            const globalAttributes = [];
            for (const [_componentName, { item, bind, on }] of componentCompletion) {
                const componentNames = nameCases.tag === 'kebabCase' ? new Set([(0, shared_1.hyphenate)(_componentName)])
                    : nameCases.tag === 'pascalCase' ? new Set([_componentName])
                        : new Set([(0, shared_1.hyphenate)(_componentName), _componentName]);
                for (const componentName of componentNames) {
                    const attributes = componentName === '*' ? globalAttributes : [];
                    for (const prop of bind) {
                        const name = nameCases.attr === 'camelCase' ? prop.label : (0, shared_1.hyphenate)(prop.label);
                        if ((0, shared_1.hyphenate)(name).startsWith('on-')) {
                            const propNameBase = name.startsWith('on-')
                                ? name.slice('on-'.length)
                                : (name['on'.length].toLowerCase() + name.slice('onX'.length));
                            const propKey = createInternalItemId('componentEvent', [componentName, propNameBase]);
                            attributes.push({
                                name: 'v-on:' + propNameBase,
                                description: propKey,
                            }, {
                                name: '@' + propNameBase,
                                description: propKey,
                            });
                            tsItems.set(propKey, prop);
                        }
                        else {
                            const propName = name;
                            const propKey = createInternalItemId('componentProp', [componentName, propName]);
                            attributes.push({
                                name: propName,
                                description: propKey,
                            }, {
                                name: ':' + propName,
                                description: propKey,
                            }, {
                                name: 'v-bind:' + propName,
                                description: propKey,
                            });
                            tsItems.set(propKey, prop);
                        }
                    }
                    for (const event of on) {
                        const name = nameCases.attr === 'camelCase' ? event.label : (0, shared_1.hyphenate)(event.label);
                        const propKey = createInternalItemId('componentEvent', [componentName, name]);
                        attributes.push({
                            name: 'v-on:' + name,
                            description: propKey,
                        });
                        attributes.push({
                            name: '@' + name,
                            description: propKey,
                        });
                        tsItems.set(propKey, event);
                    }
                    const componentKey = createInternalItemId('component', [componentName]);
                    if (componentName !== '*') {
                        tags.push({
                            name: componentName,
                            description: componentKey,
                            attributes,
                        });
                    }
                    if (item) {
                        tsItems.set(componentKey, item);
                    }
                }
            }
            const descriptor = vueDocument.file.sfc;
            const enabledComponentAutoImport = (_d = yield ((_c = (0, vue_language_service_types_1.useConfigurationHost)()) === null || _c === void 0 ? void 0 : _c.getConfiguration('volar.completion.autoImportComponent'))) !== null && _d !== void 0 ? _d : true;
            if (enabledComponentAutoImport && (descriptor.script || descriptor.scriptSetup)) {
                for (const vueDocument of options.vueDocuments.getAll()) {
                    let baseName = path.removeExt(path.basename(vueDocument.uri), '.vue');
                    if (baseName.toLowerCase() === 'index') {
                        baseName = path.basename(path.dirname(vueDocument.uri));
                    }
                    baseName = baseName.replace(/\./g, '-');
                    const componentName_1 = (0, shared_1.hyphenate)(baseName);
                    const componentName_2 = (0, shared_1.capitalize)((0, shared_1.camelize)(baseName));
                    let i = '';
                    if (componentCompletion.has(componentName_1) || componentCompletion.has(componentName_2)) {
                        i = 1;
                        while (componentCompletion.has(componentName_1 + i) || componentCompletion.has(componentName_2 + i)) {
                            i++;
                        }
                    }
                    tags.push({
                        name: (nameCases.tag === 'kebabCase' ? componentName_1 : componentName_2) + i,
                        description: createInternalItemId('importFile', [vueDocument.uri]),
                        attributes: [],
                    });
                }
            }
            const dataProvider = html.newHTMLDataProvider('vue-html', {
                version: 1.1,
                tags,
                globalAttributes,
            });
            options.templateLanguagePlugin.updateCustomData([
                vueGlobalDirectiveProvider,
                dataProvider,
            ]);
            return tsItems;
        });
    }
    function afterHtmlCompletion(completionList, vueDocument, tsItems) {
        var _a, _b, _c, _d, _e, _f, _g;
        const replacement = getReplacement(completionList, vueDocument.getDocument());
        if (replacement) {
            const isEvent = replacement.text.startsWith('@') || replacement.text.startsWith('v-on:');
            const hasModifier = replacement.text.includes('.');
            if (isEvent && hasModifier) {
                const modifiers = replacement.text.split('.').slice(1);
                const textWithoutModifier = replacement.text.split('.')[0];
                for (const modifier in eventModifiers) {
                    if (modifiers.includes(modifier))
                        continue;
                    const modifierDes = eventModifiers[modifier];
                    const newItem = {
                        label: modifier,
                        filterText: textWithoutModifier + '.' + modifier,
                        documentation: modifierDes,
                        textEdit: {
                            range: replacement.textEdit.range,
                            newText: textWithoutModifier + '.' + modifier,
                        },
                        kind: vscode.CompletionItemKind.EnumMember,
                    };
                    completionList.items.push(newItem);
                }
            }
        }
        for (const item of completionList.items) {
            const itemIdKey = typeof item.documentation === 'string' ? item.documentation : (_a = item.documentation) === null || _a === void 0 ? void 0 : _a.value;
            const itemId = itemIdKey ? readInternalItemId(itemIdKey) : undefined;
            if (itemId) {
                item.documentation = undefined;
            }
            if ((itemId === null || itemId === void 0 ? void 0 : itemId.type) === 'importFile') {
                const [fileUri] = itemId.args;
                const filePath = shared.getPathOfUri(fileUri);
                const rPath = path.relative(options.vueLsHost.getCurrentDirectory(), filePath);
                const data = {
                    mode: 'autoImport',
                    vueDocumentUri: vueDocument.uri,
                    importUri: fileUri,
                };
                item.labelDetails = { description: rPath };
                item.filterText = item.label + ' ' + rPath;
                item.detail = rPath;
                item.kind = vscode.CompletionItemKind.File;
                item.sortText = '\u0003' + ((_b = item.sortText) !== null && _b !== void 0 ? _b : item.label);
                item.data = data;
            }
            else if (itemIdKey && itemId) {
                const tsItem = itemIdKey ? tsItems.get(itemIdKey) : undefined;
                if (itemId.type === 'componentProp' || itemId.type === 'componentEvent') {
                    const [componentName] = itemId.args;
                    if (componentName !== '*') {
                        item.sortText = '\u0000' + ((_c = item.sortText) !== null && _c !== void 0 ? _c : item.label);
                    }
                    if (tsItem) {
                        if (itemId.type === 'componentProp') {
                            item.kind = vscode.CompletionItemKind.Property;
                        }
                        else {
                            item.kind = vscode.CompletionItemKind.Event;
                        }
                    }
                }
                else if (item.label === 'v-if'
                    || item.label === 'v-else-if'
                    || item.label === 'v-else'
                    || item.label === 'v-for') {
                    item.kind = vscode.CompletionItemKind.Method;
                    item.sortText = '\u0003' + ((_d = item.sortText) !== null && _d !== void 0 ? _d : item.label);
                }
                else if (item.label.startsWith('v-')) {
                    item.kind = vscode.CompletionItemKind.Function;
                    item.sortText = '\u0002' + ((_e = item.sortText) !== null && _e !== void 0 ? _e : item.label);
                }
                else {
                    item.sortText = '\u0001' + ((_f = item.sortText) !== null && _f !== void 0 ? _f : item.label);
                }
                const data = {
                    mode: 'html',
                    tsItem: tsItem,
                };
                item.data = data;
            }
        }
        {
            const temp = new Map();
            for (const item of completionList.items) {
                const data = item.data;
                if ((data === null || data === void 0 ? void 0 : data.mode) === 'autoImport' && data.importUri === vueDocument.uri) { // don't import itself
                    continue;
                }
                if (!((_g = temp.get(item.label)) === null || _g === void 0 ? void 0 : _g.documentation)) { // filter HTMLAttributes
                    temp.set(item.label, item);
                }
            }
            completionList.items = [...temp.values()];
        }
        options.templateLanguagePlugin.updateCustomData([]);
    }
    function getLastImportNode(ast) {
        let importNode;
        ast.forEachChild(node => {
            if (options.ts.isImportDeclaration(node)) {
                importNode = node;
            }
        });
        return importNode ? {
            text: importNode.getFullText(ast).trim(),
            end: importNode.getEnd(),
        } : undefined;
    }
    function getComponentCompletionData(sourceFile) {
        var _a, _b, _c, _d, _e, _f, _g;
        return __awaiter(this, void 0, void 0, function* () {
            const templateData = yield sourceFile.getTemplateData();
            let cache = componentCompletionDataCache.get(templateData);
            if (!cache) {
                cache = new Map();
                const file = (_a = sourceFile.file.allEmbeddeds.find(e => e.file.fileName === sourceFile.file.tsFileName)) === null || _a === void 0 ? void 0 : _a.file;
                const document = file ? sourceFile.getEmbeddedDocument(file) : undefined;
                const templateTagNames = [...sourceFile.getTemplateTagsAndAttrs().tags.keys()];
                if (file && document) {
                    const tags_1 = templateData.componentItems.map(item => {
                        return { item, name: item.label };
                    });
                    const tags_2 = templateTagNames
                        .filter(tag => tag.indexOf('.') >= 0)
                        .map(tag => ({ name: tag, item: undefined }));
                    for (const tag of [...tags_1, ...tags_2]) {
                        if (cache.has(tag.name))
                            continue;
                        let bind = [];
                        let on = [];
                        {
                            const searchText = vue.SearchTexts.PropsCompletion(tag.name);
                            let offset = file.codeGen.getText().indexOf(searchText);
                            if (offset >= 0) {
                                offset += searchText.length;
                                try {
                                    bind = (_c = (_b = (yield options.tsLs.doComplete(document.uri, document.positionAt(offset)))) === null || _b === void 0 ? void 0 : _b.items.map(entry => { entry.label = entry.label.replace('?', ''); return entry; }).filter(entry => entry.kind !== vscode.CompletionItemKind.Text)) !== null && _c !== void 0 ? _c : [];
                                }
                                catch (_h) { }
                            }
                        }
                        {
                            const searchText = vue.SearchTexts.EmitCompletion(tag.name);
                            let offset = file.codeGen.getText().indexOf(searchText);
                            if (offset >= 0) {
                                offset += searchText.length;
                                try {
                                    on = (_e = (_d = (yield options.tsLs.doComplete(document.uri, document.positionAt(offset)))) === null || _d === void 0 ? void 0 : _d.items.map(entry => { entry.label = entry.label.replace('?', ''); return entry; }).filter(entry => entry.kind !== vscode.CompletionItemKind.Text)) !== null && _e !== void 0 ? _e : [];
                                }
                                catch (_j) { }
                            }
                        }
                        cache.set(tag.name, { item: tag.item, bind, on });
                    }
                    try {
                        const offset = file.codeGen.getText().indexOf(vue.SearchTexts.GlobalAttrs);
                        const globalBind = (_g = (_f = (yield options.tsLs.doComplete(document.uri, document.positionAt(offset)))) === null || _f === void 0 ? void 0 : _f.items.map(entry => { entry.label = entry.label.replace('?', ''); return entry; }).filter(entry => entry.kind !== vscode.CompletionItemKind.Text)) !== null && _g !== void 0 ? _g : [];
                        cache.set('*', { item: undefined, bind: globalBind, on: [] });
                    }
                    catch (_k) { }
                }
                componentCompletionDataCache.set(templateData, cache);
            }
            return cache;
        });
    }
}
exports.default = useVueTemplateLanguagePlugin;
function createInternalItemId(type, args) {
    return '__VLS_::' + type + '::' + args.join(',');
}
function readInternalItemId(key) {
    if (key.startsWith('__VLS_::')) {
        const strs = key.split('::');
        return {
            type: strs[1],
            args: strs[2].split(','),
        };
    }
}
function getReplacement(list, doc) {
    for (const item of list.items) {
        if (item.textEdit && 'range' in item.textEdit) {
            return {
                item: item,
                textEdit: item.textEdit,
                text: doc.getText(item.textEdit.range)
            };
        }
    }
}
//# sourceMappingURL=vue-template.js.map